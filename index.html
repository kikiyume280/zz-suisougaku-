<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>合作音ゲー（設計修正版）</title>
  <link rel="icon" href="data:," />
  <style>
    body{font-family: system-ui, sans-serif; margin:0; padding:0; display:flex; flex-direction:column; min-height:100vh; background:#f5f5f7}
    #top{padding:12px; display:flex; gap:8px; align-items:center; background:#fff; border-bottom:1px solid #ddd}
    #statusBar{margin-left:12px; font-size:14px; color:#333}
    #bigStatus { font-size:28px; font-weight:800; color:#111; margin:12px 0; text-align:center; }
    #waiting,#waiting2,#game,#result{display:none; padding:12px}
    .role { padding:8px; border-radius:6px; margin:6px; display:inline-flex; gap:8px; align-items:center; min-width:160px; white-space:pre-line}
    .role .label { font-size:12px; color:#222; background:rgba(255,255,255,0.12); padding:2px 6px; border-radius:4px }
    #lane{position:relative; height:60vh; background:#000; color:white; overflow:hidden; border-radius:8px}
    .note{ position:absolute; left:50%; transform:translateX(-50%); width:80%; height:16px; border-radius:4px; text-align:center; line-height:16px; font-size:14px; opacity:0.95; transition:opacity 0.06s linear}
    #judgeLine{position:absolute; bottom:60px; left:0; right:0; height:8px; background:rgba(255,255,255,0.92); z-index:5}
    #controls{position:fixed; right:12px; bottom:12px; z-index:999}
    #rolesList{display:flex; flex-wrap:wrap; gap:8px; justify-content:center}
    #transientText{position:absolute; left:50%; transform:translateX(-50%); bottom:90px; font-size:28px; font-weight:700; color:#fff; text-shadow:0 0 6px #000; pointer-events:none; opacity:0; transition:opacity 0.12s linear}
    #countdown { text-align:center; font-size:16px; color:#eee; margin-top:6px }
  </style>
</head>
<body>
  <div id="top">
    <button id="joinBtn">参加</button>
    <div style="margin-left:auto; display:flex; align-items:center; gap:8px">
      <div class="small">運営パス</div>
      <input id="adminPw" placeholder="" style="width:110px; padding:6px"/>
      <button id="adminApply">決定</button>
      <div id="userInfo">未参加</div>
      <div id="statusBar">状態: <span id="stateText">--</span></div>
    </div>
  </div>

  <div id="waiting">
    <div id="bigStatus">セッション待機中</div>
    <div id="rolesList"></div>
    <div id="topBalls"></div>
    <div id="controls" style="text-align:center; margin-top:12px">
      <button id="startBtn" style="display:none">開始（運営）</button>
      <button id="adminReset" style="display:none">強制終了（運営）</button>
    </div>
  </div>

  <div id="waiting2">
    <div style="max-width:900px; margin:0 auto; background:#fff; padding:16px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.08)">
      <div class="bigStatus" id="waiting2Big">演奏終了 — 集計・合成中</div>
      <div id="waiting2Status" class="small">現在: --</div>
      <div style="margin-top:12px">
        <audio id="waiting2Audio" controls style="width:100%"></audio>
        <div style="margin-top:8px; text-align:center">
          <button id="waiting2Download" style="display:none">保存（MP3）</button>
          <button id="waiting2Back">戻る（待機へ）</button>
        </div>
      </div>
    </div>
  </div>

  <div id="game">
    <h3 id="roleTitle"></h3>
    <div id="lane">
      <div id="judgeLine"></div>
      <div id="transientText"></div>
    </div>
    <div id="countdown"></div>
    <p style="text-align:center">スペースキー／タップで判定（PERFECT: ±0.5s）</p>
  </div>

  <div id="result">
    <h3>完成！</h3>
    <audio id="finalAudio" controls></audio>
    <div style="margin-top:8px; text-align:center">
      <button id="downloadBtn">保存（MP3）</button>
      <button id="backBtn">戻る（待機へ）</button>
    </div>
  </div>

  <script type="module">
/* ===== CONFIG: ここを直接編集 ===== */
const CONFIG = {
  overrideAssets: true,
  assets: {
    "@": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/kyoku.mp3",
    "miss": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/miss.mp3",
    "A": { clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/A.mp3", color:"#FF6666", label:"シンバル", guideTimes:["0:18.00","0:25.56"] },
    "B": { clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/B.mp3", color:"#66CCFF", label:"カスタネット", guideTimes:["0:27.50","0:28.21"] },
    "C": { clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/C.mp3", color:"#2F1226", label:"ドラム", guideTimes:["0:17.07","0:20.02"] }
  },
  rolesOrder: ["A","B","C"]
};
/* ================================== */

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getDatabase, ref, onValue, set, update, get, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-database.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "...", // ← 必ずご自分の値に置き換えてください
  authDomain: "suisougaku-bdcc0.firebaseapp.com",
  projectId: "suisougaku-bdcc0",
  databaseURL: "https://suisougaku-bdcc0-default-rtdb.firebaseio.com/",
  storageBucket: "suisougaku-bdcc0.appspot.com",
  messagingSenderId: "636001978886",
  appId: "1:636001978886:web:24e68f1ef5b66dc7fa5187",
  measurementId: "G-Y04PFJ9BQ6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

const sessionId = "session-proto-1";
const sessionRef = ref(db, `sessions/${sessionId}`);
const finalDataRef = ref(db, `sessions/${sessionId}/finalData`);
const finalRecordsRef = ref(db, `sessions/${sessionId}/finalRecords`);

let uid = null, userName = null, userRole = null;
let isAdmin = false, adminApplied = false;
let startServerTime = null, serverOffset = 0;
let assets = null, audioContext = null;
let baseAudioBuffer = null, roleAudioBuffer = null, missAudioBuffer = null;
let localClicks = []; // array of {t}
let currentSessionSnapshot = null;
let baseSourceNode = null, baseEndTimer = null;

// DOM
const joinBtn = document.getElementById('joinBtn');
const adminApplyBtn = document.getElementById('adminApply');
const adminPwInput = document.getElementById('adminPw');
const startBtn = document.getElementById('startBtn');
const adminResetBtn = document.getElementById('adminReset');
const rolesListEl = document.getElementById('rolesList');
const waitingEl = document.getElementById('waiting');
const waiting2El = document.getElementById('waiting2');
const waiting2StatusEl = document.getElementById('waiting2Status');
const waiting2Audio = document.getElementById('waiting2Audio');
const waiting2Download = document.getElementById('waiting2Download');
const waiting2Back = document.getElementById('waiting2Back');
const gameEl = document.getElementById('game');
const roleTitleEl = document.getElementById('roleTitle');
const laneEl = document.getElementById('lane');
const transientTextEl = document.getElementById('transientText');
const countdownEl = document.getElementById('countdown');
const userInfoEl = document.getElementById('userInfo');
const stateTextEl = document.getElementById('stateText');
const bigStatusEl = document.getElementById('bigStatus');
const finalAudioEl = document.getElementById('finalAudio');
const downloadBtn = document.getElementById('downloadBtn');
const backBtn = document.getElementById('backBtn');

(async function init(){
  try {
    await signInAnonymously(auth);
    uid = auth.currentUser.uid;
  } catch(e){
    alert('Firebase Auth failed: enable Anonymous sign-in.');
    console.error(e);
  }

  joinBtn.addEventListener('click', joinFlow);
  adminApplyBtn.addEventListener('click', onAdminApply);
  startBtn.addEventListener('click', onStartClicked);
  adminResetBtn.addEventListener('click', onAdminReset);
  waiting2Download.addEventListener('click', onDownloadWaiting2MP3);
  waiting2Back.addEventListener('click', () => { waiting2El.style.display='none'; waitingEl.style.display='block'; });

  onValue(sessionRef, snap => {
    currentSessionSnapshot = snap.val() || {};
    // pick assets: CONFIG override or DB assets
    if (CONFIG.overrideAssets || !(currentSessionSnapshot.assets && Object.keys(currentSessionSnapshot.assets).length)) assets = normalizeConfigAssets(CONFIG.assets || {});
    else assets = normalizeConfigAssets(currentSessionSnapshot.assets || {});
    startServerTime = currentSessionSnapshot.startServerTime || null;
    updateStateUI(currentSessionSnapshot.status || 'waiting');
    renderRolesView(currentSessionSnapshot);
    // UI state transitions
    const status = currentSessionSnapshot.status || 'waiting';
    if (status === 'running') {
      // if our uid is a player, show game
      if (currentSessionSnapshot.players && currentSessionSnapshot.players[uid]) { userRole = currentSessionSnapshot.players[uid].role; showGame(); }
      else { waitingEl.style.display='block'; gameEl.style.display='none'; waiting2El.style.display='none'; }
    } else if (status === 'collecting' || status === 'compiling' || status === 'finished') {
      // show waiting2 for all participants
      waiting2El.style.display='block';
      waitingEl.style.display='none';
      gameEl.style.display='none';
    } else {
      waitingEl.style.display='block';
      waiting2El.style.display='none';
      gameEl.style.display='none';
    }
  });

  // finalData listener: when operator writes finalData, all clients will receive it
  onValue(finalDataRef, snap => {
    const v = snap.val();
    if (v && v.dataUrl) {
      // show waiting2 with final
      waiting2El.style.display='block';
      waitingEl.style.display='none';
      gameEl.style.display='none';
      waiting2StatusEl.textContent = '合成完了';
      waiting2Audio.src = v.dataUrl;
      waiting2Download.style.display = 'inline-block';
      waiting2Download.dataset.url = v.dataUrl;
      finalAudioEl.src = v.dataUrl;
      downloadBtn.dataset.url = v.dataUrl;
    }
  });

  await estimateServerOffset();
  window.addEventListener('resize', adjustLaneHeight);
  adjustLaneHeight();
})();

// ========== Utilities ==========
function normalizeConfigAssets(raw) {
  const out = {};
  for (const k of Object.keys(raw || {})) {
    if (k === '@' || k === 'miss') { out[k] = raw[k]; continue; }
    const v = raw[k] || {};
    out[k] = { clipUrl: v.clipUrl || v.url || null, color: v.color || '#777', label: v.label || '', guideTimes: (v.guideTimes||[]).map(parseTimeToSeconds) };
  }
  if (raw['@']) out['@'] = raw['@'];
  if (raw['miss']) out['miss'] = raw['miss'];
  return out;
}
function parseTimeToSeconds(val) {
  if (typeof val === 'number') return val;
  const s = String(val).trim();
  if (!s) return 0;
  if (s.indexOf(':') === -1) return parseFloat(s) || 0;
  const parts = s.split(':').map(p=>p.trim());
  if (parts.length===3) return (+parts[0])*3600 + (+parts[1])*60 + parseFloat(parts[2]);
  if (parts.length===2) return (+parts[0])*60 + parseFloat(parts[1]);
  return parseFloat(parts[0])||0;
}
function adjustLaneHeight(){ laneEl.style.height = `${Math.max(360, window.innerHeight*0.62)}px`; }
function getContrastYIQ(hexcolor){ try { if (!hexcolor.startsWith('#')) return '#fff'; const r=parseInt(hexcolor.substr(1,2),16); const g=parseInt(hexcolor.substr(3,2),16); const b=parseInt(hexcolor.substr(5,2),16); const yiq=((r*299)+(g*587)+(b*114))/1000; return yiq>=128 ? '#000':'#fff'; } catch(e){ return '#fff'; } }

// ========== UI rendering ==========
function updateStateUI(status) {
  const map = { waiting:'待機中', running:'演奏中', collecting:'集計中', compiling:'合成中', finished:'完成' };
  stateTextEl.textContent = map[status] || status;
  bigStatusEl.textContent = map[status] ? `状態: ${map[status]}` : '状態: --';
  isAdmin = adminApplied;
  adminResetBtn.style.display = isAdmin ? 'inline-block' : 'none';
  startBtn.style.display = isAdmin ? 'inline-block' : 'none';
}
function renderRolesView(sessionData) {
  rolesListEl.innerHTML = '';
  const roles = sessionData.rolesOrder || CONFIG.rolesOrder || Object.keys(assets||{}).filter(k=>k!=='@'&&k!=='miss');
  for (const r of roles) {
    const info = assets[r] || {};
    const color = info.color || '#777';
    const el = document.createElement('div'); el.className='role'; el.style.background=color; el.style.color=getContrastYIQ(color);
    const letter = document.createElement('div'); letter.textContent=r; letter.style.fontWeight='700';
    const label = document.createElement('div'); label.className='label'; label.textContent = info.label || '';
    el.appendChild(letter); el.appendChild(label);
    // list assigned player names (can be multiple)
    const players = Object.entries(sessionData.players||{})
      .filter(([puid,p]) => p.role === r)
      .map(([puid,p]) => p.name);
    if (players.length) { const namesDiv = document.createElement('div'); namesDiv.textContent = players.join(', '); namesDiv.style.marginLeft='8px'; el.appendChild(namesDiv); }
    rolesListEl.appendChild(el);
  }
  if (sessionData.players && sessionData.players[uid]) { userInfoEl.textContent = `あなた: ${sessionData.players[uid].name} (${sessionData.players[uid].role})`; userRole = sessionData.players[uid].role; }
  else { userInfoEl.textContent = '未参加'; }
}

// ========== Join / Admin / Start / Reset ==========
async function joinFlow(){
  const name = prompt('名前を入力してください');
  if (!name) return;
  userName = name.trim() || '名無し';
  const snap = await get(sessionRef);
  const session = snap.val() || {};
  const players = session.players || {};
  const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets||{}).filter(k=>k!=='@'&&k!=='miss');
  // assign next role cyclically, but multiple per role allowed => simply assign first role in rolesOrder in round-robin by count
  // Count existing assignments per role and pick role with smallest count
  const counts = {};
  for (const r of rolesOrder) counts[r]=0;
  for (const p of Object.values(players||{})) if (p && p.role) counts[p.role] = (counts[p.role]||0)+1;
  let roleToAssign = rolesOrder[0];
  let min = counts[roleToAssign];
  for (const r of rolesOrder) { if (counts[r] < min) { roleToAssign=r; min=counts[r]; } }
  await set(ref(db, `sessions/${sessionId}/players/${uid}`), { name: userName, role: roleToAssign, joinedAt: Date.now() });
  userRole = roleToAssign;
  waitingEl.style.display='block';
}

function onAdminApply(){
  const val = adminPwInput.value;
  if (val === '1122') { adminApplied=true; isAdmin=true; updateStateUI(currentSessionSnapshot.status||'waiting'); alert('運営モードになりました'); }
  else alert('パスワード不正');
}

async function onStartClicked(){
  if (!isAdmin) { alert('運営権限が必要'); return; }
  const delayStr = prompt('開始までの遅延秒（秒）を入力してください（0 で即時）', '5');
  const delay = Math.max(0, Math.floor(Number(delayStr) || 5));
  // set ownerUid so only owner composes later
  try {
    // write status running and startServerTime = serverTimestamp() + delay*1000, ownerUid
    await update(sessionRef, { status: 'running', ownerUid: uid, startServerTime: serverTimestamp() });
    // Now also write a scheduledStart field with server-side offset: we cannot add milliseconds to serverTimestamp directly.
    // Workaround: set scheduledDelay and ownerUid; clients compute target = startServerTime + scheduledDelay*1000 using serverTimestamp read-back
    await update(sessionRef, { scheduledDelaySec: delay });
    // also auto-record for empty roles under sessions/records/__auto_<role> (so they are included)
    const snap = await get(sessionRef);
    const session = snap.val() || {};
    const players = session.players || {};
    const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets||{}).filter(k=>k!=='@'&&k!=='miss');
    for (const r of rolesOrder) {
      const assigned = Object.values(players||{}).some(p=>p.role===r);
      if (!assigned) {
        const guideTimes = assets[r] && assets[r].guideTimes || [];
        const autoUid = `__auto_${r}`;
        const autoClicks = guideTimes.map(t => ({ t }));
        await set(ref(db, `sessions/${sessionId}/records/${autoUid}`), autoClicks);
      }
    }
    // NOTE: clients will compute actual start time as serverTimestamp + scheduledDelay after reading startServerTime (see client logic)
  } catch(e){ console.error(e); alert('開始処理に失敗しました'); }
}

async function onAdminReset(){
  if (!confirm('強制終了しますか？（assetsは残します）')) return;
  try {
    const keepAssets = currentSessionSnapshot.assets || CONFIG.assets || {};
    const payload = { status: 'waiting', assets: keepAssets, rolesOrder: currentSessionSnapshot.rolesOrder || CONFIG.rolesOrder || CONFIG.rolesOrder };
    await set(sessionRef, payload);
    await set(ref(db, `sessions/${sessionId}/players`), null);
    await set(ref(db, `sessions/${sessionId}/records`), null);
    await set(ref(db, `sessions/${sessionId}/realtimeActions`), null);
    await set(ref(db, `sessions/${sessionId}/finalData`), null);
    await set(ref(db, `sessions/${sessionId}/finalRecords`), null);
    alert('初期化しました');
  } catch(e){ console.error(e); alert('初期化失敗'); }
}

// ========== GAME: rendering notes, countdown, playback ==========
async function showGame(){
  waitingEl.style.display='none'; waiting2El.style.display='none'; gameEl.style.display='block';
  roleTitleEl.textContent = `あなたの役割: ${userRole||'未割当'}`;
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  localClicks = [];
  await prepareAudioBuffersForRole();
  // compute scheduled start: read startServerTime + scheduledDelaySec (serverTimestamp returns ms)
  const snap = await get(sessionRef);
  const session = snap.val() || {};
  startServerTime = session.startServerTime || null; // serverTimestamp value
  const scheduledDelay = (session.scheduledDelaySec || 0) * 1000;
  // compute actual start = startServerTime + scheduledDelay - note: startServerTime is numeric (ms) stored earlier by serverTimestamp reading
  // Use estimateServerOffset to align client clock
  if (!startServerTime) {
    console.warn('startServerTime missing'); renderNotesForRole(); return;
  }
  const targetStartMs = Number(startServerTime) + scheduledDelay;
  // show countdown until start and schedule playback at targetStartMs
  const updateCountdown = () => {
    const nowMs = Date.now() + serverOffset;
    const remainingMs = Math.max(0, targetStartMs - nowMs);
    const remainingSec = Math.ceil(remainingMs/1000);
    countdownEl.textContent = remainingMs>0 ? `開始まで残り：${remainingSec} 秒` : '';
    if (remainingMs <= 0) { countdownEl.textContent=''; clearInterval(countdownTimer); startPlaybackFromOffset((nowMs - targetStartMs)/1000); }
  };
  let countdownTimer = setInterval(updateCountdown, 250);
  updateCountdown();
  renderNotesForRole(targetStartMs);
}

async function prepareAudioBuffersForRole(){
  try { baseAudioBuffer = baseAudioBuffer || await fetchAndDecode(assets['@']); } catch(e){ console.error('base load fail', e); }
  if (assets['miss']) try { missAudioBuffer = missAudioBuffer || await fetchAndDecode(assets['miss']); } catch(e){ console.warn('miss load fail', e); }
  if (assets[userRole] && assets[userRole].clipUrl) try { roleAudioBuffer = roleAudioBuffer || await fetchAndDecode(assets[userRole].clipUrl); } catch(e){ console.warn('role load fail', e); }
}

function startPlaybackFromOffset(offsetSec) {
  // offsetSec: how many seconds into base to start (>=0)
  if (!audioContext || !baseAudioBuffer) return;
  if (baseSourceNode) try{ baseSourceNode.disconnect(); }catch(e){}
  baseSourceNode = audioContext.createBufferSource();
  baseSourceNode.buffer = baseAudioBuffer;
  baseSourceNode.connect(audioContext.destination);
  if (offsetSec <= 0) baseSourceNode.start();
  else if (offsetSec >= baseAudioBuffer.duration) { onBaseEnded(); return; }
  else baseSourceNode.start(0, offsetSec);
  // schedule end handler
  const remainingMs = (baseAudioBuffer.duration - offsetSec)*1000;
  if (baseEndTimer) clearTimeout(baseEndTimer);
  baseEndTimer = setTimeout(()=>{ onBaseEnded(); }, Math.max(0, remainingMs + 50));
}

function renderNotesForRole(startMs = Date.now()+serverOffset) {
  laneEl.querySelectorAll('.note').forEach(n=>n.remove());
  const times = (assets[userRole] && assets[userRole].guideTimes) || [];
  const travelMs = 3000;
  const baseStartMs = startServerTime ? (Number(startServerTime) + (currentSessionSnapshot.scheduledDelaySec||0)*1000) : startMs;
  times.forEach((gtime, idx) => {
    const targetMs = baseStartMs + Math.round(gtime*1000);
    const appearAt = targetMs - travelMs;
    const div = document.createElement('div');
    div.className='note'; div.dataset.guide=String(gtime); div.dataset.appearAt=String(appearAt); div.dataset.targetAt=String(targetMs);
    div.style.background = (assets[userRole] && assets[userRole].color) || '#444';
    div.style.color = getContrastYIQ(assets[userRole] && assets[userRole].color || '#444');
    laneEl.appendChild(div);
    const animate = () => {
      const t = Date.now() + serverOffset;
      const pct = (t - appearAt)/travelMs;
      const laneH = laneEl.clientHeight; const startY = laneH - 16; const endY = 60;
      if (pct >= 1.6) { div.style.opacity='0'; setTimeout(()=>div.remove(),300); return; }
      if (pct <= 0) { div.style.bottom = `${startY}px`; requestAnimationFrame(animate); }
      else { const y = startY - (startY - endY)*Math.min(pct,1); div.style.bottom = `${y}px`; requestAnimationFrame(animate); }
    };
    requestAnimationFrame(animate);
  });
}

// When user presses during game
function recordLocalClick(){
  if (!startServerTime) { alert('まだ開始されていません'); return; }
  const nowClientMs = Date.now() + serverOffset;
  const session = currentSessionSnapshot || {};
  const scheduledDelay = (session.scheduledDelaySec || 0)*1000;
  const baseStartMs = Number(session.startServerTime || startServerTime) + scheduledDelay;
  const relativeSec = Math.max(0, (nowClientMs - baseStartMs)/1000);
  localClicks.push({ t: relativeSec });
  const res = evaluateHitAndHandleNote(relativeSec);
  showTransient(res === 'perfect' ? 'PERFECT' : 'MISS', res === 'perfect' ? '#8ef27a' : '#ff6b6b');
  broadcastAction(res === 'perfect' ? 'perfect' : 'miss');
}
function evaluateHitAndHandleNote(relativeSec) {
  const notes = Array.from(laneEl.querySelectorAll('.note'));
  if (!notes.length) return evaluateHit(relativeSec);
  let best=null, bestDiff=Infinity;
  for (const n of notes) {
    const guide = parseFloat(n.dataset.guide)||0; const d=Math.abs(guide-relativeSec);
    if (d<bestDiff){bestDiff=d; best=n;}
  }
  if (!best) return evaluateHit(relativeSec);
  const isPerfect = bestDiff <= 0.5;
  const appearAt = Number(best.dataset.appearAt), targetMs = Number(best.dataset.targetAt);
  const travelMs = targetMs - appearAt; const t=Date.now()+serverOffset; const pct=(t-appearAt)/(travelMs||1);
  if (isPerfect) { playRoleClipNow(); best.remove(); return 'perfect'; }
  else { if (pct>1) best.remove(); playMissClipNow(); return 'miss'; }
}
function evaluateHit(relativeSec){
  const times = (assets[userRole] && assets[userRole].guideTimes) || [];
  let bestDiff=Infinity; for (const gt of times){ const d=Math.abs(gt-relativeSec); if (d<bestDiff) bestDiff=d; }
  return bestDiff<=0.5 ? 'perfect' : 'miss';
}
async function playRoleClipNow(){ try { if (!roleAudioBuffer && assets[userRole]) roleAudioBuffer = await fetchAndDecode(assets[userRole].clipUrl); if (roleAudioBuffer){ const s=audioContext.createBufferSource(); s.buffer=roleAudioBuffer; s.connect(audioContext.destination); s.start(); } } catch(e){console.warn(e);} }
async function playMissClipNow(){ try { if (!missAudioBuffer && assets['miss']) missAudioBuffer = await fetchAndDecode(assets['miss']); if (missAudioBuffer){ const s=audioContext.createBufferSource(); s.buffer=missAudioBuffer; s.connect(audioContext.destination); s.start(); } } catch(e){console.warn(e);} }
function showTransient(text,color){ transientTextEl.style.color=color||'#fff'; transientTextEl.textContent=text; transientTextEl.style.opacity='1'; setTimeout(()=>transientTextEl.style.opacity='0',700); }
async function broadcastAction(kind){ try { await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), { kind, name:userName||uid, time: serverTimestamp() }); setTimeout(async()=>{ try{ await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), null); }catch(e){} },900); } catch(e){ console.warn(e); } }
onValue(ref(db, `sessions/${sessionId}/realtimeActions`), snap=>{ const v=snap.val()||{}; topBallsEl.innerHTML=''; for(const [puid,data] of Object.entries(v)){ if(!data) continue; const b=document.createElement('div'); b.className='ball'; b.textContent=data.kind==='perfect'?'P':'X'; topBallsEl.appendChild(b);} });

// ========== base end: send records, operator-only compose ==========
async function onBaseEnded(){
  // write our localClicks for this uid
  try { await set(ref(db, `sessions/${sessionId}/records/${uid}`), localClicks); } catch(e){ console.warn(e); }
  // set status collecting
  try { await update(sessionRef, { status: 'collecting' }); } catch(e){}
  // Only operator composes: operator is session.ownerUid
  const session = (await get(sessionRef)).val() || {};
  const ownerUid = session.ownerUid;
  if (ownerUid && ownerUid === uid) {
    // operator will wait for records and then compose
    await operatorWaitAndCompose(session);
  } else {
    // non-operator: wait for finalData written by operator (finalDataRef listener handles UI)
    console.log('非運営: 合成完了を待ちます');
  }
}

async function operatorWaitAndCompose(sessionAtStart) {
  // get snapshot of players at start (use sessionAtStart.players to avoid players joining later)
  const playersSnapshot = sessionAtStart.players || {};
  const expectedUids = Object.keys(playersSnapshot);
  // include auto roles if not assigned
  const rolesOrder = sessionAtStart.rolesOrder || CONFIG.rolesOrder || Object.keys(assets||{}).filter(k=>k!=='@'&&k!=='miss');
  for (const r of rolesOrder) {
    const assigned = Object.values(playersSnapshot||{}).some(p=>p.role===r);
    if (!assigned) expectedUids.push(`__auto_${r}`);
  }
  // Wait until records/<uid> exist for all expected UIDs or timeout
  const TIMEOUT_MS = 20000; // 20s timeout (tweakable)
  const startWait = Date.now();
  while (true) {
    const recordsSnap = (await get(ref(db, `sessions/${sessionId}/records`))).val() || {};
    const have = Object.keys(recordsSnap || {});
    const missing = expectedUids.filter(e => !have.includes(e));
    if (missing.length === 0) {
      // all arrived
      // Compose: first ensure auto records exist (they were created at start)
      await composeAndPublish(recordsSnap, sessionAtStart, expectedUids);
      break;
    }
    if (Date.now() - startWait > TIMEOUT_MS) {
      // timeout: compose with what we have, but ensure auto roles are synthesized
      const recs = (await get(ref(db, `sessions/${sessionId}/records`))).val() || {};
      // fill missing auto roles locally (not writing DB) — but better to write auto to DB earlier; we did at start.
      await composeAndPublish(recs, sessionAtStart, expectedUids);
      break;
    }
    await new Promise(r=>setTimeout(r, 700));
  }
}

async function composeAndPublish(allRecords, sessionAtStart, expectedUids) {
  // allRecords: object uid -> [{t},...]
  // sessionAtStart: players and roles snapshot at operator start
  // expectedUids: list including auto uids

  // ensure allRecords includes auto ones (we attempted to write them earlier; if not, synthesize from assets and write them)
  const rolesOrder = sessionAtStart.rolesOrder || CONFIG.rolesOrder || Object.keys(assets||{}).filter(k=>k!=='@'&&k!=='miss');
  for (const r of rolesOrder) {
    const assigned = Object.values(sessionAtStart.players||{}).some(p=>p.role===r);
    const autoUid = `__auto_${r}`;
    if (!assigned && !(allRecords && allRecords[autoUid])) {
      const guideTimes = (assets[r] && assets[r].guideTimes) || [];
      const autoClicks = guideTimes.map(t => ({ t }));
      // write into DB so others also see numeric data
      try { await set(ref(db, `sessions/${sessionId}/records/${autoUid}`), autoClicks); } catch(e){ console.warn('auto write fail', e); }
      allRecords[autoUid] = autoClicks;
    }
  }

  // now create finalRecords structure (for later re-editing) and also mix audio
  // finalRecords: array of { uid, role, clicks: [t1,t2,...] }
  const finalRecords = [];
  for (const uidKey of Object.keys(allRecords || {})) {
    const clicks = (allRecords[uidKey] || []).map(e => Number(e.t || 0));
    // determine role for this uid: either from players snapshot or "__auto_X" gives role
    let role = null;
    if (sessionAtStart.players && sessionAtStart.players[uidKey]) role = sessionAtStart.players[uidKey].role;
    if (!role && uidKey.startsWith('__auto_')) role = uidKey.replace('__auto_','');
    finalRecords.push({ uid: uidKey, role, clicks });
  }

  // Publish finalRecords to DB so it's available for re-editing
  try { await set(finalRecordsRef, finalRecords); } catch(e){ console.warn('finalRecords write failed', e); }

  // Mix audio and produce dataURL (operator only)
  const dataUrl = await mixAllToDataUrl(allRecords, sessionAtStart);
  if (dataUrl) {
    // publish final data if not exists (avoid race)
    const snap = await get(finalDataRef);
    if (!snap.val()) {
      try { await set(finalDataRef, { dataUrl, generatedBy: uid, generatedAt: serverTimestamp() }); } catch(e){ console.warn('finalData write failed', e); }
    }
    // also update session status
    try { await update(sessionRef, { status: 'finished' }); } catch(e){}
  }
}

// Compose offline and return dataURL
async function mixAllToDataUrl(allRecords, sessionAtStart) {
  // gather uid->role mapping
  const uidToRole = {};
  for (const [puid, pdata] of Object.entries(sessionAtStart.players || {})) uidToRole[puid] = pdata.role;
  const rolesOrder = sessionAtStart.rolesOrder || CONFIG.rolesOrder || Object.keys(assets||{}).filter(k=>k!=='@'&&k!=='miss');
  for (const r of rolesOrder) {
    const autoUid = `__auto_${r}`;
    if (allRecords[autoUid]) uidToRole[autoUid] = r;
  }

  // ensure base buffer ready
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  if (!baseAudioBuffer) try { baseAudioBuffer = await fetchAndDecode(assets['@']); } catch(e){ console.error(e); return null; }

  // compute duration
  let maxT = baseAudioBuffer.duration;
  for (const arr of Object.values(allRecords || {})) for (const ev of arr) if (ev.t && ev.t > maxT) maxT = ev.t;
  const sampleRate = 44100;
  const off = new OfflineAudioContext(2, Math.ceil((maxT + 2) * sampleRate), sampleRate);

  // base
  const baseSrc = off.createBufferSource();
  baseSrc.buffer = baseAudioBuffer;
  baseSrc.connect(off.destination);
  baseSrc.start(0);

  // schedule each uid's clicks using its role's clip
  for (const [puid, arr] of Object.entries(allRecords || {})) {
    const role = uidToRole[puid] || (puid.startsWith('__auto_') ? puid.replace('__auto_','') : null);
    const clipUrl = role && assets[role] && assets[role].clipUrl;
    if (!clipUrl) continue;
    try {
      const clipBuf = await fetchAndDecode(clipUrl);
      for (const ev of arr) {
        const t = Number(ev.t || 0);
        const s = off.createBufferSource();
        s.buffer = clipBuf;
        s.connect(off.destination);
        s.start(t);
      }
    } catch(e){ console.warn('clip load fail', role, e); continue; }
  }

  const rendered = await off.startRendering();
  try { await loadLameJs(); } catch(e){ console.warn('lame load failed', e); }
  const blob = (typeof lamejs !== 'undefined') ? audioBufferToMp3(rendered) : audioBufferToWav(rendered);
  const dataUrl = await blobToDataURL(blob);
  return dataUrl;
}

// ========== MP3/WAV helpers (lamejs) ==========
let lameLoaded=false;
async function loadLameJs(){ if(lameLoaded) return; return new Promise((resolve,reject)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js'; s.onload=()=>{ lameLoaded=true; resolve(); }; s.onerror=(e)=>{ reject(e); }; document.head.appendChild(s); }); }
function audioBufferToMp3(audioBuffer){
  if (typeof lamejs === 'undefined') return audioBufferToWav(audioBuffer);
  const left = audioBuffer.getChannelData(0);
  const right = audioBuffer.numberOfChannels>1 ? audioBuffer.getChannelData(1) : left;
  const samples = interleaveFloat32(left, right);
  const mp3encoder = new lamejs.Mp3Encoder(2, audioBuffer.sampleRate, 128);
  const mp3Data=[];
  const block=1152;
  let idx=0;
  while(idx < samples.length){
    const leftChunk=[], rightChunk=[];
    for(let i=0;i<block && idx < samples.length; i+=2){ leftChunk.push(samples[idx]); rightChunk.push(samples[idx+1]); idx+=2; }
    const left16 = floatTo16BitPCMArray(leftChunk);
    const right16 = floatTo16BitPCMArray(rightChunk);
    const mp3buf = mp3encoder.encodeBuffer(left16, right16);
    if (mp3buf.length) mp3Data.push(mp3buf);
  }
  const mp3buf = mp3encoder.flush();
  if (mp3buf.length) mp3Data.push(mp3buf);
  return new Blob(mp3Data, { type: 'audio/mp3' });
}
function interleaveFloat32(left,right){ const len = left.length + right.length; const out = new Float32Array(len); let idx=0,i=0; while(i<left.length){ out[idx++]=left[i]; out[idx++]=right[i]; i++; } return out; }
function floatTo16BitPCMArray(float32Array){ const out = new Int16Array(float32Array.length); for(let i=0;i<float32Array.length;i++){ const s=Math.max(-1,Math.min(1,float32Array[i])); out[i]=s<0? s*0x8000 : s*0x7FFF; } return out; }
function audioBufferToWav(buffer){ /* (same as earlier) */ const opt={}; var numChannels = buffer.numberOfChannels; var sampleRate = buffer.sampleRate; var format = 1; var bitDepth = 16; var result = numChannels===2 ? interleave(buffer.getChannelData(0), buffer.getChannelData(1)) : buffer.getChannelData(0); return encodeWAV(result, format, sampleRate, numChannels, bitDepth); }
function interleave(a,b){ var length=a.length+b.length; var res=new Float32Array(length); var idx=0,i=0; while(i<a.length){ res[idx++]=a[i]; res[idx++]=b[i]; i++; } return res; }
function encodeWAV(samples, format, sampleRate, numChannels, bitDepth){ var bytesPerSample=bitDepth/8; var blockAlign = numChannels * bytesPerSample; var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample); var view = new DataView(buffer); writeString(view,0,'RIFF'); view.setUint32(4,36 + samples.length * bytesPerSample, true); writeString(view,8,'WAVE'); writeString(view,12,'fmt '); view.setUint32(16,16,true); view.setUint16(20, format===3?3:1, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * blockAlign, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bitDepth, true); writeString(view,36,'data'); view.setUint32(40, samples.length * bytesPerSample, true); floatTo16BitPCM(view,44,samples); return new Blob([buffer], { type: 'audio/wav' }); }
function floatTo16BitPCM(output, offset, input){ for(var i=0;i<input.length;i++,offset+=2){ var s=Math.max(-1,Math.min(1,input[i])); output.setInt16(offset, s<0? s*0x8000 : s*0x7FFF, true); } }
function writeString(view, offset, string){ for(var i=0;i<string.length;i++){ view.setUint8(offset+i, string.charCodeAt(i)); } }
function blobToDataURL(blob){ return new Promise(r=>{ const fr=new FileReader(); fr.onload=()=>r(fr.result); fr.readAsDataURL(blob); }); }

// ========== fetch & decode ==========
async function fetchAndDecode(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error('fetch failed '+res.status);
  const ab = await res.arrayBuffer();
  if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  return await audioContext.decodeAudioData(ab);
}

// ========== operator helpers: download handlers & waiting2 download ==========
function onDownloadWaiting2MP3(){ const url = waiting2Download.dataset.url; if(!url) return alert('なし'); const a=document.createElement('a'); a.href=url; a.download='gassaku.mp3'; a.click(); }
function onDownloadMP3(){ const url = downloadBtn.dataset.url || finalAudioEl.src; if(!url) return alert('なし'); const a=document.createElement('a'); a.href=url; a.download='gassaku.mp3'; a.click(); }

// ========== server time ping ==========
async function estimateServerOffset(){
  const rand=Math.random().toString(36).slice(2,8); const p=[]; for(let i=0;i<6;i++){ const t0=Date.now(); const tempRef = ref(db, `__serverTimeTest/${uid}_${rand}_${i}`); try{ await set(tempRef, {ts: serverTimestamp()}); const snap=await get(tempRef); const serverTs = snap.val() && snap.val().ts; const t1=Date.now(); if(serverTs){ const rtt=t1-t0; const offset = serverTs - (t0 + rtt/2); p.push(offset); } } catch(e){ console.warn(e); } await new Promise(r=>setTimeout(r,50)); } if(p.length){ p.sort((a,b)=>a-b); serverOffset = p[Math.floor(p.length/2)]; } else serverOffset = 0; console.log('serverOffset', serverOffset); }

// ========== Explanations (why previous design failed) ==========
/*
- 1クライアントが勝手に合成してしまう問題:
    -> 原因: 複数クライアントが「全員分が揃った」と考え合成を開始してしまった (race condition)
    -> 対策: session.ownerUid を設定し、合成の責務は ownerUid のクライアントのみが行うように限定。同時起動を防ぐ。

- 参加者 15 人以上で一部しか入らない問題:
    -> 原因: 合成時に期待するレコードUIDが players の snapshot と一致しない / mixing 対象が limited
    -> 対策: records のキーをすべて走査し uid 単位でスケジューリング。players に存在する複数人同一 role を許容。

- 同一ロールに複数人入ると壊れる:
    -> 対策: uid を最小単位として扱う（uid -> role mapping を作り、各 uid の clicks をその role の clip でスケジュール。これで同一 role の複数人を自然に扱える）

- スマホ/PC 混在、送信順のズレ:
    -> 対策: 合成開始は operator が records の存在を確認してから行う（timeout を設ける）。個々のプレイヤーは自分の records を sessions/.../records/<uid> に一回だけ書き込む（上書きではなく set）。operator は players snapshot (start時) を基準に必須 uid を決める。

- finalRecords を保存:
    -> 対策: operator が finalRecords (uid, role, clicks[]) を sessions/.../finalRecords に書き込む。これにより再編集可能。

- DB への MP3 (dataURL) 配信:
    -> operator が finalData (dataUrl) を sessions/.../finalData に set する。全クライアントはその変更を監視して同じ最終音声を再生・保存できる。

- カウントダウン表示:
    -> 対策: start 時に scheduledDelaySec を書き、クライアントは startServerTime + scheduledDelaySec を参照して "開始まで残り: N 秒" を表示。0 で消える。

- ノーツの通過と消去ルール:
    -> PERFECT: ノーツ即時消去 + role clip 再生
    -> MISS: ノーツは判定線を越えて通過して消える（画面外）
*/

// End of file
  </script>
</body>
</html>
