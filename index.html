<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>合作音ゲー（修正版：完成配信＋待機2＋ラベル表示）</title>
  <!-- Avoid browser requesting /favicon.ico (prevents 404) -->
  <link rel="icon" href="data:," />
  <style>
    body{font-family: system-ui, sans-serif; margin:0; padding:0; display:flex; flex-direction:column; min-height:100vh; background:#f5f5f7}
    #top{padding:12px; display:flex; gap:8px; align-items:center; background:#fff; border-bottom:1px solid #ddd}
    #statusBar{margin-left:12px; font-size:14px; color:#333}
    /* Big prominent status for waiting screen */
    #bigStatus { font-size:28px; font-weight:800; color:#111; margin:12px 0; text-align:center; }
    #waiting,#waiting2,#game,#result{display:none; padding:12px}
    .role { padding:8px; border-radius:6px; margin:6px; display:inline-flex; gap:8px; align-items:center; min-width:160px; white-space:pre-line}
    .role .label { font-size:12px; color:#222; background:rgba(255,255,255,0.12); padding:2px 6px; border-radius:4px }
    #lane{position:relative; height:60vh; background:#000; color:white; overflow:hidden; border-radius:8px}
    .note{ position:absolute; left:50%; transform:translateX(-50%); width:80%; height:16px; border-radius:4px; text-align:center; line-height:16px; font-size:14px; opacity:0.95; transition:opacity 0.06s linear}
    #judgeLine{position:absolute; bottom:60px; left:0; right:0; height:8px; background:rgba(255,255,255,0.92); z-index:5}
    #topBalls{display:flex; gap:6px; margin-top:6px; flex-wrap:wrap}
    .ball{width:34px; height:34px; border-radius:50%; background:#666; display:flex; align-items:center; justify-content:center; color:white; font-size:12px}
    #controls{position:fixed; right:12px; bottom:12px; z-index:999}
    #rolesList{display:flex; flex-wrap:wrap; gap:8px; justify-content:center}
    #roleTitle{margin-bottom:8px}
    button{cursor:pointer}
    .small{font-size:12px; color:#666}
    input[type="text"]{padding:6px}
    #transientText{position:absolute; left:50%; transform:translateX(-50%); bottom:90px; font-size:28px; font-weight:700; color:#fff; text-shadow:0 0 6px #000; pointer-events:none; opacity:0; transition:opacity 0.12s linear}
    #userInfo{font-size:13px; color:#333; margin-left:12px}
    #adminApply{margin-left:6px}
    /* waiting2 (pseudo waiting room after song) */
    #waiting2 .panel { background:#fff; padding:16px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.08); max-width:900px; margin:0 auto }
    #waiting2 .bigStatus { font-size:20px; margin-bottom:8px; text-align:center; font-weight:700; color:#222 }
    #waiting2 .small{ text-align:center; color:#666 }
  </style>
</head>
<body>
  <div id="top">
    <button id="joinBtn">参加</button>
    <div style="margin-left:auto; display:flex; align-items:center; gap:8px">
      <div class="small">運営パス</div>
      <input id="adminPw" placeholder="1122" style="width:110px; padding:6px"/>
      <button id="adminApply">決定</button>
      <div id="userInfo">未参加</div>
      <div id="statusBar">状態: <span id="stateText">--</span></div>
    </div>
  </div>

  <div id="waiting">
    <div id="bigStatus">セッション待機中</div>
    <div id="rolesList"></div>
    <div id="topBalls"></div>
    <div id="controls" style="text-align:center; margin-top:12px">
      <button id="startBtn" style="display:none">開始（運営）</button>
      <button id="adminReset" style="display:none">強制終了（運営）</button>
    </div>
  </div>

  <div id="waiting2">
    <div class="panel">
      <div class="bigStatus" id="waiting2Big">演奏終了 — 集計・合成中</div>
      <div id="waiting2Status" class="small">現在: --</div>
      <div style="margin-top:12px">
        <audio id="waiting2Audio" controls style="width:100%"></audio>
        <div style="margin-top:8px; text-align:center">
          <button id="waiting2Download" style="display:none">保存（MP3）</button>
          <button id="waiting2Back">戻る（待機へ）</button>
        </div>
      </div>
    </div>
  </div>

  <div id="game">
    <h3 id="roleTitle"></h3>
    <div id="lane">
      <div id="judgeLine"></div>
      <div id="transientText"></div>
    </div>
    <p style="text-align:center">スペースキー／タップで判定（PERFECT: ±0.5s）</p>
  </div>

  <div id="result">
    <h3>完成！</h3>
    <audio id="finalAudio" controls></audio>
    <div style="margin-top:8px; text-align:center">
      <button id="downloadBtn">保存（MP3）</button>
      <button id="backBtn">戻る（待機へ）</button>
    </div>
  </div>

  <script type="module">
/*
  改修点（要求に合わせて既存機能を保持しつつ追加）
  - favicon 404 対策（head に data: 形式の favicon）
  - 完成音声（MP3）の dataURL を Realtime DB の sessions/<id>/finalData に保存して全員に配信
    → これで全クライアントが同じ final を受け取り再生・保存・戻るが可能に
  - waiting2（演奏終了専用の大きめ表示待機画面）を導入。合成中・完了をここで表示
  - 待機画面のステータスを大きく表示
  - CONFIG.assets.<role>.label を追加（1語の楽器名等）。待機画面の各 role 表示に横並びで表示
  - ノーツの線上で PERFECT 時はその role の clip を鳴らしノーツを即消去、MISS 時は判定ラインを過ぎるまで残す（通過後消去）
  - 「戻る（待機へ）」ボタンでクライアントはホームの待機画面へ戻る（session データは維持）
*/

  // ------------------ CONFIG（直接編集） ------------------
  const CONFIG = {
    overrideAssets: true,
    assets: {
      "@": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/kyoku.mp3",
      "miss": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/miss.mp3",
      "A": {
        clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/A.mp3",
        color: "#FF6666",
        label: "Tambourine",                 // 新機能: 1語の楽器名をここに書くと待機画面に表示
        guideTimes: ["0:18.00", "0:25.56", "0:38.12","0:54.94","0:57.80"]
      },
      "B": {
        clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/B.mp3",
        color: "#66CCFF",
        label: "Bell",
        guideTimes: ["0:27.50","0:28.21","0:28.83","0:29.60","0:30.32","0:31.01","0:31.78","0:32.48","0:33.15","0:34.66","0:35.38","0:36.02","0:36.75","0:42.09","0:44.09","0:54.96","0:57.77"]
      }
    },
    rolesOrder: ["A","B","C","D","E","F","G","H","I"]
  };
  // ---------------------------------------------------------------------

  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
  import { getDatabase, ref, onValue, set, update, get, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-database.js";
  import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBePhUfYinZ02-1BWbZvzV3IBwoAYh-kxE",
    authDomain: "suisougaku-bdcc0.firebaseapp.com",
    projectId: "suisougaku-bdcc0",
    databaseURL: "https://suisougaku-bdcc0-default-rtdb.firebaseio.com/",
    storageBucket: "suisougaku-bdcc0.appspot.com",
    messagingSenderId: "636001978886",
    appId: "1:636001978886:web:24e68f1ef5b66dc7fa5187",
    measurementId: "G-Y04PFJ9BQ6"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const auth = getAuth(app);

  // globals
  const sessionId = "session-proto-1";
  const sessionRef = ref(db, `sessions/${sessionId}`);
  const finalDataRef = ref(db, `sessions/${sessionId}/finalData`);

  let uid = null;
  let userName = null;
  let userRole = null;
  let isAdmin = false;
  let adminApplied = false;
  let startServerTime = null;
  let serverOffset = 0;
  let assets = null;
  let audioContext = null;
  let baseAudioBuffer = null;
  let roleAudioBuffer = null;
  let missAudioBuffer = null;
  let localClicks = []; // [{t}]
  let currentSessionSnapshot = null;
  let baseSourceNode = null;
  let baseEndTimer = null;

  // DOM
  const joinBtn = document.getElementById('joinBtn');
  const startBtn = document.getElementById('startBtn');
  const adminResetBtn = document.getElementById('adminReset');
  const adminApplyBtn = document.getElementById('adminApply');
  const adminPwInput = document.getElementById('adminPw');
  const rolesListEl = document.getElementById('rolesList');
  const waitingEl = document.getElementById('waiting');
  const waiting2El = document.getElementById('waiting2');
  const waiting2StatusEl = document.getElementById('waiting2Status');
  const waiting2Audio = document.getElementById('waiting2Audio');
  const waiting2Download = document.getElementById('waiting2Download');
  const waiting2Back = document.getElementById('waiting2Back');
  const gameEl = document.getElementById('game');
  const resultEl = document.getElementById('result');
  const roleTitleEl = document.getElementById('roleTitle');
  const laneEl = document.getElementById('lane');
  const topBallsEl = document.getElementById('topBalls');
  const finalAudioEl = document.getElementById('finalAudio');
  const downloadBtn = document.getElementById('downloadBtn');
  const backBtn = document.getElementById('backBtn');
  const transientTextEl = document.getElementById('transientText');
  const userInfoEl = document.getElementById('userInfo');
  const stateTextEl = document.getElementById('stateText');
  const bigStatusEl = document.getElementById('bigStatus');

  // init
  (async function init(){
    try {
      await signInAnonymously(auth);
      uid = auth.currentUser.uid;
      console.log('signed in uid=', uid);
    } catch (err) {
      console.error('auth error', err);
      alert('Firebase 匿名ログインに失敗しました。Console で Anonymous を有効にしてください。\n' + err.message);
    }

    joinBtn.addEventListener('click', joinFlow);
    startBtn.addEventListener('click', onStartClicked);
    adminResetBtn.addEventListener('click', onAdminReset);
    adminApplyBtn.addEventListener('click', onAdminApply);
    downloadBtn.addEventListener('click', onDownloadMP3);
    waiting2Download.addEventListener('click', onDownloadWaiting2MP3);
    waiting2Back.addEventListener('click', () => { waiting2El.style.display='none'; waitingEl.style.display='block'; });

    onValue(sessionRef, snapshot => {
      const v = snapshot.val();
      currentSessionSnapshot = v || {};
      if (CONFIG.overrideAssets || !(currentSessionSnapshot.assets && Object.keys(currentSessionSnapshot.assets).length)) {
        assets = normalizeConfigAssets(CONFIG.assets || {});
      } else {
        assets = normalizeConfigAssets(currentSessionSnapshot.assets || {});
      }
      startServerTime = currentSessionSnapshot.startServerTime || null;
      updateStateUI(currentSessionSnapshot.status || 'waiting');
      updateRolesView(currentSessionSnapshot);

      const status = currentSessionSnapshot.status || 'waiting';
      // switch to waiting2 for collecting/compiling/finished
      if (status === 'collecting' || status === 'compiling' || status === 'finished') {
        waiting2El.style.display = 'block';
        waitingEl.style.display = 'none';
        gameEl.style.display = 'none';
      } else if (status === 'running') {
        // if we are in players, show game
        if (currentSessionSnapshot.players && currentSessionSnapshot.players[uid]) {
          userRole = currentSessionSnapshot.players[uid].role;
          showGame();
        } else {
          // keep waiting screen
          waitingEl.style.display = 'block';
          waiting2El.style.display = 'none';
          gameEl.style.display = 'none';
        }
      } else {
        waitingEl.style.display = 'block';
        waiting2El.style.display = 'none';
        gameEl.style.display = 'none';
      }
    });

    // listen for finalData (data URL) so all clients show final playback & save
    onValue(finalDataRef, snap => {
      const v = snap.val();
      if (v && v.dataUrl) {
        // show waiting2 with final
        waiting2El.style.display = 'block';
        waitingEl.style.display = 'none';
        gameEl.style.display = 'none';
        waiting2StatusEl.textContent = '合成完了';
        waiting2Audio.src = v.dataUrl;
        waiting2Download.style.display = 'inline-block';
        waiting2Download.dataset.url = v.dataUrl;
      }
    });

    await estimateServerOffset();
    window.addEventListener('resize', adjustLaneHeight);
    adjustLaneHeight();
  })();

  // normalize and parse times, include label
  function normalizeConfigAssets(rawAssets) {
    const out = {};
    for (const k of Object.keys(rawAssets || {})) {
      if (k === '@' || k === 'miss') {
        out[k] = rawAssets[k];
        continue;
      }
      const v = rawAssets[k] || {};
      out[k] = {
        clipUrl: v.clipUrl || v.url || null,
        color: v.color || '#777',
        label: v.label || '',                 // new label field
        guideTimes: (v.guideTimes || []).map(parseTimeToSeconds)
      };
    }
    if (rawAssets['@']) out['@'] = rawAssets['@'];
    if (rawAssets['miss']) out['miss'] = rawAssets['miss'];
    return out;
  }
  function parseTimeToSeconds(val) {
    if (val === null || val === undefined) return 0;
    if (typeof val === 'number') return val;
    const s = String(val).trim();
    if (!s) return 0;
    if (s.indexOf(':') === -1) {
      const f = parseFloat(s);
      return isFinite(f) ? f : 0;
    }
    const parts = s.split(':').map(p => p.trim());
    let seconds = 0;
    if (parts.length === 3) {
      const h = parseInt(parts[0]) || 0;
      const m = parseInt(parts[1]) || 0;
      const sec = parseFloat(parts[2].replace(',', '.')) || 0;
      seconds = h*3600 + m*60 + sec;
    } else if (parts.length === 2) {
      const m = parseInt(parts[0]) || 0;
      const sec = parseFloat(parts[1].replace(',', '.')) || 0;
      seconds = m*60 + sec;
    } else {
      seconds = parseFloat(parts[0].replace(',', '.')) || 0;
    }
    return seconds;
  }

  // UI / DB
  function updateStateUI(status) {
    const map = { waiting:'待機中', running:'演奏中', collecting:'集計中', compiling:'合成中', finished:'完成' };
    stateTextEl.textContent = map[status] || status;
    bigStatusEl.textContent = map[status] ? `状態: ${map[status]}` : '状態: --';
    isAdmin = adminApplied;
    adminResetBtn.style.display = isAdmin ? 'inline-block' : 'none';
    startBtn.style.display = isAdmin ? 'inline-block' : 'none';
  }

  function updateRolesView(sessionData) {
    rolesListEl.innerHTML = '';
    const rolesOrder = sessionData.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
    (rolesOrder).forEach(role => {
      const info = assets && assets[role];
      const color = info?.color || '#777';
      const el = document.createElement('div');
      el.className = 'role';
      el.style.background = color;
      el.style.color = getContrastYIQ(color);
      // role letter + label
      const letter = document.createElement('div');
      letter.textContent = role;
      letter.style.fontWeight = '700';
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = (info && info.label) ? info.label : '';
      el.appendChild(letter);
      el.appendChild(label);
      // names under role
      const names = [];
      for (const [puid, pdata] of Object.entries(sessionData.players || {})) {
        if (pdata.role === role) names.push(pdata.name);
      }
      if (names.length) {
        const namesDiv = document.createElement('div');
        namesDiv.textContent = names.join(', ');
        namesDiv.style.marginLeft = '8px';
        el.appendChild(namesDiv);
      }
      rolesListEl.appendChild(el);
    });

    if (sessionData.players && sessionData.players[uid]) {
      userInfoEl.textContent = `あなた: ${sessionData.players[uid].name} (${sessionData.players[uid].role})`;
      userRole = sessionData.players[uid].role;
    } else {
      userInfoEl.textContent = '未参加';
    }
  }

  async function joinFlow(){
    const name = prompt('名前を入力してください');
    if (!name) return;
    userName = name.trim() || '名無し';
    const snap = await get(sessionRef);
    const session = snap.val() || {};
    const players = session.players || {};
    const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
    const assigned = Object.values(players).map(p => p.role);
    let roleToAssign = null;
    for (const r of rolesOrder) {
      if (!assigned.includes(r)) { roleToAssign = r; break; }
    }
    if (!roleToAssign) roleToAssign = rolesOrder[assigned.length % rolesOrder.length];
    await set(ref(db, `sessions/${sessionId}/players/${uid}`), { name: userName, role: roleToAssign, joinedAt: Date.now() });
    userRole = roleToAssign;
    userInfoEl.textContent = `あなた: ${userName} (${userRole})`;
    waitingEl.style.display = 'block';
  }

  async function onAdminApply(){
    const val = adminPwInput.value;
    if (val === '1122') {
      adminApplied = true;
      isAdmin = true;
      updateStateUI(currentSessionSnapshot.status || 'waiting');
      alert('運営モードに切り替わりました');
    } else {
      alert('パスワードが違います');
    }
  }

  async function onStartClicked(){
    if (!isAdmin) { alert('運営パスが必要です'); return; }
    try {
      await update(sessionRef, { status: 'running', startServerTime: serverTimestamp() });
      // auto records for empty roles
      const snap = await get(sessionRef);
      const session = snap.val() || {};
      const players = session.players || {};
      const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
      for (const r of rolesOrder) {
        const assignedNames = Object.values(players).filter(p => p.role === r);
        if (!assignedNames.length) {
          const guideTimes = (assets[r] && assets[r].guideTimes) || [];
          const autoUid = `__auto_${r}`;
          const autoClicks = guideTimes.map(t => ({ t }));
          await set(ref(db, `sessions/${sessionId}/records/${autoUid}`), autoClicks);
        }
      }
      await update(sessionRef, { finalMeta: null });
    } catch (e) {
      console.error('start failed', e);
      alert('開始に失敗しました。Console を確認してください。');
    }
  }

  async function onAdminReset(){
    if (!confirm('本当に強制終了してセッションの参加者/記録を初期化しますか？（assetsは維持されます）')) return;
    try {
      const keepAssets = currentSessionSnapshot.assets || CONFIG.assets || {};
      const payload = { status: 'waiting', assets: keepAssets, rolesOrder: currentSessionSnapshot.rolesOrder || CONFIG.rolesOrder || CONFIG.rolesOrder };
      await set(sessionRef, payload);
      await set(ref(db, `sessions/${sessionId}/players`), null);
      await set(ref(db, `sessions/${sessionId}/records`), null);
      await set(ref(db, `sessions/${sessionId}/realtimeActions`), null);
      await set(ref(db, `sessions/${sessionId}/startServerTime`), null);
      await set(ref(db, `sessions/${sessionId}/finalMeta`), null);
      await set(ref(db, `sessions/${sessionId}/finalData`), null);
      alert('強制終了しました。参加者データと記録を削除しました。');
    } catch(e) {
      console.error('reset failed', e);
      alert('強制終了に失敗しました。Console を確認してください。');
    }
  }

  // gameplay
  function showGame(){
    waitingEl.style.display = 'none';
    waiting2El.style.display = 'none';
    gameEl.style.display = 'block';
    resultEl.style.display = 'none';
    roleTitleEl.textContent = `あなたの役割: ${userRole || '未割当'}`;
    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
    localClicks = [];
    loadAssetsAndStart();
    window.addEventListener('keydown', onKeyDown);
    laneEl.addEventListener('touchstart', onTouchStart, {passive:true});
  }

  function onKeyDown(e){
    if (e.code === 'Space') { e.preventDefault(); recordLocalClick(); }
  }
  function onTouchStart(e){ recordLocalClick(); }

  async function loadAssetsAndStart(){
    if (!assets || !assets['@']) { alert('ベース曲(@)が設定されていません。'); return; }
    try { baseAudioBuffer = await fetchAndDecode(assets['@']); } catch(e){ console.error('base load error', e); alert('ベース曲読み込み失敗'); return; }
    if (assets['miss']) { try { missAudioBuffer = await fetchAndDecode(assets['miss']); } catch(e){ console.warn('miss load failed', e); } }
    const roleUrl = assets[userRole] && assets[userRole].clipUrl;
    if (roleUrl) { try { roleAudioBuffer = await fetchAndDecode(roleUrl); } catch(e){ console.warn('role clip load failed', e); } }

    if (startServerTime) scheduleBasePlaybackAndEndHandler();
    else {
      const unSub = onValue(sessionRef, snap => {
        const v = snap.val() || {};
        if (v.startServerTime && v.status === 'running') {
          startServerTime = v.startServerTime;
          scheduleBasePlaybackAndEndHandler();
          unSub();
        }
      });
    }
    renderNotesForRole();
  }

  function scheduleBasePlaybackAndEndHandler(){
    if (!audioContext || !baseAudioBuffer || !startServerTime) return;
    const nowClientMs = Date.now() + serverOffset;
    const elapsedMs = nowClientMs - startServerTime;
    const elapsedSec = Math.max(0, elapsedMs/1000);

    if (baseSourceNode) { try { baseSourceNode.disconnect(); } catch(e){} baseSourceNode = null; }
    baseSourceNode = audioContext.createBufferSource();
    baseSourceNode.buffer = baseAudioBuffer;
    baseSourceNode.connect(audioContext.destination);

    if (elapsedSec <= 0) baseSourceNode.start(audioContext.currentTime + (-elapsedSec), 0);
    else {
      if (elapsedSec >= baseAudioBuffer.duration) { onBaseEnded(); return; }
      else baseSourceNode.start(audioContext.currentTime, elapsedSec);
    }

    const remainingMs = (baseAudioBuffer.duration - elapsedSec) * 1000;
    if (baseEndTimer) clearTimeout(baseEndTimer);
    baseEndTimer = setTimeout(() => { onBaseEnded(); }, Math.max(0, remainingMs + 50));
  }

  function renderNotesForRole(){
    laneEl.querySelectorAll('.note').forEach(n => n.remove());
    const times = (assets && assets[userRole] && assets[userRole].guideTimes) || [];
    const travelMs = 3000;
    const baseServerStartMs = startServerTime || (Date.now() + serverOffset);
    times.forEach((gtime, idx) => {
      const targetMs = baseServerStartMs + Math.round(gtime*1000);
      const appearAt = targetMs - travelMs;
      const div = document.createElement('div');
      div.className = 'note';
      div.dataset.guide = String(gtime);
      div.dataset.appearAt = String(appearAt);
      div.dataset.targetAt = String(targetMs);
      div.style.background = (assets[userRole] && assets[userRole].color) || '#444';
      div.style.color = getContrastYIQ(assets[userRole] && assets[userRole].color || '#444');
      laneEl.appendChild(div);

      const animate = () => {
        const t = Date.now() + serverOffset;
        const pct = (t - appearAt) / travelMs;
        const laneHeight = laneEl.clientHeight;
        const startY = laneHeight - 16;
        const endY = 60;
        if (pct >= 1.5) { div.style.opacity='0'; setTimeout(()=>div.remove(),300); return; }
        if (pct <= 0) { div.style.bottom = `${startY}px`; requestAnimationFrame(animate); }
        else { const y = startY - (startY - endY) * Math.min(pct,1); div.style.bottom = `${y}px`; requestAnimationFrame(animate); }
      };
      requestAnimationFrame(animate);
    });
  }

  // record during play; after base ends send to DB
  function recordLocalClick(){
    if (!startServerTime) { alert('まだ開始されていません'); return; }
    const clientNow = Date.now();
    const relativeMs = (clientNow + serverOffset) - startServerTime;
    const relativeSec = Math.max(0, relativeMs/1000);
    localClicks.push({ t: relativeSec });
    const res = evaluateHitAndHandleNote(relativeSec);
    showTransientText(res === 'perfect' ? 'PERFECT' : 'MISS', res === 'perfect' ? '#8ef27a' : '#ff6b6b');
    broadcastAction(res === 'perfect' ? 'perfect' : 'miss');
  }

  function evaluateHitAndHandleNote(relativeSec){
    const notes = Array.from(laneEl.querySelectorAll('.note'));
    if (!notes.length) return evaluateHit(relativeSec);
    let bestNote = null;
    let bestDiff = Infinity;
    for (const n of notes) {
      const guide = parseFloat(n.dataset.guide) || 0;
      const d = Math.abs(guide - relativeSec);
      if (d < bestDiff) { bestDiff = d; bestNote = n; }
    }
    if (!bestNote) return evaluateHit(relativeSec);
    const isPerfect = bestDiff <= 0.5;
    const appearAt = Number(bestNote.dataset.appearAt);
    const targetMs = Number(bestNote.dataset.targetAt);
    const travelMs = targetMs - appearAt;
    const t = Date.now() + serverOffset;
    const pct = (t - appearAt) / (travelMs || 1);

    if (isPerfect) {
      playRoleClipNow();
      bestNote.remove();
      return 'perfect';
    } else {
      if (pct > 1) bestNote.remove();
      playMissClipNow();
      return 'miss';
    }
  }

  function evaluateHit(relativeSec){
    const times = (assets && assets[userRole] && assets[userRole].guideTimes) || [];
    let bestDiff = Infinity;
    for (const gt of times) {
      const d = Math.abs(gt - relativeSec);
      if (d < bestDiff) bestDiff = d;
    }
    return bestDiff <= 0.5 ? 'perfect' : 'miss';
  }

  async function playRoleClipNow(){
    try {
      if (!roleAudioBuffer && assets[userRole] && assets[userRole].clipUrl) roleAudioBuffer = await fetchAndDecode(assets[userRole].clipUrl);
      if (roleAudioBuffer && audioContext) { const src = audioContext.createBufferSource(); src.buffer = roleAudioBuffer; src.connect(audioContext.destination); src.start(); }
    } catch(e){ console.warn('playRoleClipNow failed', e); }
  }
  async function playMissClipNow(){
    try {
      if (!missAudioBuffer && assets['miss']) missAudioBuffer = await fetchAndDecode(assets['miss']);
      if (missAudioBuffer && audioContext) { const src = audioContext.createBufferSource(); src.buffer = missAudioBuffer; src.connect(audioContext.destination); src.start(); }
    } catch(e){ console.warn('playMissClipNow failed', e); }
  }

  async function broadcastAction(kind){
    try {
      await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), { kind, name: userName || uid, time: serverTimestamp() });
      setTimeout(async () => { try { await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), null); } catch(e){} }, 900);
    } catch(e){ console.warn(e); }
  }
  onValue(ref(db, `sessions/${sessionId}/realtimeActions`), snap => {
    const v = snap.val() || {};
    topBallsEl.innerHTML = '';
    for (const [puid, data] of Object.entries(v)) {
      if (!data) continue;
      const b = document.createElement('div');
      b.className = 'ball';
      b.textContent = data.kind === 'perfect' ? 'P' : 'X';
      topBallsEl.appendChild(b);
    }
  });

  function showTransientText(text, color){
    transientTextEl.style.color = color || '#fff';
    transientTextEl.textContent = text;
    transientTextEl.style.opacity = '1';
    setTimeout(()=> { transientTextEl.style.opacity = '0'; }, 700);
  }

  // base ended: send records, move to waiting2, wait for others and mix
  async function onBaseEnded(){
    console.log('ベース曲が終了');
    try { await set(ref(db, `sessions/${sessionId}/records/${uid}`), localClicks); } catch(e){ console.warn('send records failed', e); }
    waiting2El.style.display = 'block';
    waitingEl.style.display = 'none';
    gameEl.style.display = 'none';
    waiting2StatusEl.textContent = '全員の記録を集計中…';
    try { await update(sessionRef, { status: 'collecting' }); } catch(e){}
    await waitForAllRecordsThenMix();
  }

  async function waitForAllRecordsThenMix(){
    const TIMEOUT_MS = 15000;
    const startWait = Date.now();
    while (true) {
      const snap = await get(sessionRef);
      const session = snap.val() || {};
      const players = session.players || {};
      const expectedUids = Object.keys(players);
      const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
      for (const r of rolesOrder) {
        const assigned = Object.values(players || {}).some(p => p.role === r);
        if (!assigned) expectedUids.push(`__auto_${r}`);
      }
      const recordsSnap = (await get(ref(db, `sessions/${sessionId}/records`))).val() || {};
      const have = Object.keys(recordsSnap || {});
      const missing = expectedUids.filter(e => !have.includes(e));
      if (missing.length === 0) {
        try { await update(sessionRef, { status: 'compiling' }); } catch(e){}
        waiting2StatusEl.textContent = '合成処理に入る…';
        const recs = recordsSnap;
        const dataUrl = await clientMixAndProduceDataUrl(recs, session);
        // publish finalData to DB so all clients show playback/save/back
        await publishFinalDataOnce(dataUrl);
        try { await update(sessionRef, { status: 'finished', finalMeta: { generatedBy: uid, generatedAt: serverTimestamp() } }); } catch(e){}
        break;
      }
      if (Date.now() - startWait > TIMEOUT_MS) {
        try { await update(sessionRef, { status: 'compiling' }); } catch(e){}
        waiting2StatusEl.textContent = 'タイムアウト: 現在ある記録で合成します';
        const recs = (await get(ref(db, `sessions/${sessionId}/records`))).val() || {};
        const dataUrl = await clientMixAndProduceDataUrl(recs, session);
        await publishFinalDataOnce(dataUrl);
        try { await update(sessionRef, { status: 'finished', finalMeta: { generatedBy: uid, generatedAt: serverTimestamp() } }); } catch(e){}
        break;
      }
      await new Promise(r => setTimeout(r, 600));
    }
  }

  async function clientMixAndProduceDataUrl(allRecords, session) {
    // ensure auto records
    const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
    for (const r of rolesOrder) {
      const assigned = Object.values(session.players || {}).some(p => p.role === r);
      const autoUid = `__auto_${r}`;
      if (!assigned && !(allRecords && allRecords[autoUid])) {
        const guideTimes = (assets[r] && assets[r].guideTimes) || [];
        allRecords[autoUid] = guideTimes.map(t => ({ t }));
      }
    }

    const uidToRole = {};
    for (const [puid, pdata] of Object.entries(session.players || {})) uidToRole[puid] = pdata.role;
    for (const r of rolesOrder) {
      const autoUid = `__auto_${r}`;
      if (allRecords[autoUid]) uidToRole[autoUid] = r;
    }

    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (!baseAudioBuffer) { try { baseAudioBuffer = await fetchAndDecode(assets['@']); } catch(e){ console.error('base reload failed', e); return null; } }

    let maxT = baseAudioBuffer.duration;
    for (const arr of Object.values(allRecords || {})) for (const ev of arr) if (ev.t && ev.t > maxT) maxT = ev.t;
    const sampleRate = 44100;
    const off = new OfflineAudioContext(2, Math.ceil((maxT + 2) * sampleRate), sampleRate);

    const baseSrc = off.createBufferSource();
    baseSrc.buffer = baseAudioBuffer;
    baseSrc.connect(off.destination);
    baseSrc.start(0);

    for (const [puid, arr] of Object.entries(allRecords || {})) {
      const role = uidToRole[puid] || puid.replace('__auto_','');
      const clipUrl = assets[role] && assets[role].clipUrl;
      if (!clipUrl) continue;
      try {
        const clipBuf = await fetchAndDecode(clipUrl);
        for (const ev of arr) {
          const t = ev.t || 0;
          const src = off.createBufferSource();
          src.buffer = clipBuf;
          src.connect(off.destination);
          src.start(t);
        }
      } catch (e) { console.warn('clip load failed for', role, e); continue; }
    }

    waiting2StatusEl.textContent = '合成中…';
    const rendered = await off.startRendering();
    // convert to mp3 (if lame available) else wav
    try { await loadLameJs(); } catch(e){ console.warn('lame load failed', e); }
    let blob;
    if (typeof lamejs !== 'undefined') blob = audioBufferToMp3(rendered);
    else blob = audioBufferToWav(rendered);
    // convert to data URL
    const dataUrl = await blobToDataURL(blob);
    // set local UI
    waiting2Audio.src = dataUrl;
    waiting2Download.style.display = 'inline-block';
    waiting2Download.dataset.url = dataUrl;
    finalAudioEl.src = dataUrl;
    downloadBtn.dataset.url = dataUrl;
    waiting2StatusEl.textContent = '合成完了';
    return dataUrl;
  }

  async function publishFinalDataOnce(dataUrl) {
    if (!dataUrl) return;
    // write finalData only if not exists
    const snap = await get(finalDataRef);
    if (snap && snap.val()) return; // already exists
    try {
      await set(finalDataRef, { dataUrl, generatedBy: uid, generatedAt: serverTimestamp() });
    } catch(e) { console.warn('publish final failed', e); }
  }

  // --- MP3 encoding (lamejs) and helpers ---
  let lameLoaded = false;
  async function loadLameJs() {
    if (lameLoaded) return;
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js';
      s.onload = () => { lameLoaded = true; resolve(); };
      s.onerror = (e) => { console.warn('lamejs load failed', e); reject(e); };
      document.head.appendChild(s);
    });
  }

  function audioBufferToMp3(audioBuffer) {
    if (typeof lamejs === 'undefined') return audioBufferToWav(audioBuffer);
    const left = audioBuffer.getChannelData(0);
    const right = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : left;
    const samples = interleaveFloat32(left, right);
    const mp3encoder = new lamejs.Mp3Encoder(2, audioBuffer.sampleRate, 128);
    const mp3Data = [];
    const sampleBlockSize = 1152;
    let idx = 0;
    while (idx < samples.length) {
      const leftChunk = [];
      const rightChunk = [];
      for (let i=0;i<sampleBlockSize && idx < samples.length;i+=2) {
        leftChunk.push(samples[idx]); rightChunk.push(samples[idx+1]); idx+=2;
      }
      const left16 = floatTo16BitPCMArray(leftChunk);
      const right16 = floatTo16BitPCMArray(rightChunk);
      const mp3buf = mp3encoder.encodeBuffer(left16, right16);
      if (mp3buf.length > 0) mp3Data.push(mp3buf);
    }
    const mp3buf = mp3encoder.flush();
    if (mp3buf.length > 0) mp3Data.push(mp3buf);
    return new Blob(mp3Data, { type: 'audio/mp3' });
  }
  function interleaveFloat32(left, right) {
    const length = left.length + right.length;
    const result = new Float32Array(length);
    let index = 0, inputIndex = 0;
    while (inputIndex < left.length) {
      result[index++] = left[inputIndex];
      result[index++] = right[inputIndex];
      inputIndex++;
    }
    return result;
  }
  function floatTo16BitPCMArray(float32Array) {
    const out = new Int16Array(float32Array.length);
    for (let i=0;i<float32Array.length;i++){ let s = Math.max(-1, Math.min(1, float32Array[i])); out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF; }
    return out;
  }

  // fetch & decode
  async function fetchAndDecode(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error('fetch failed: ' + res.status);
    const ab = await res.arrayBuffer();
    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
    return await audioContext.decodeAudioData(ab);
  }

  // convert blob -> dataURL
  function blobToDataURL(blob) {
    return new Promise((resolve) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.readAsDataURL(blob);
    });
  }

  // download handlers
  function onDownloadMP3() {
    const url = downloadBtn.dataset.url;
    if (!url) return alert('生成された音声がありません');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'gassaku.mp3';
    a.click();
  }
  function onDownloadWaiting2MP3() {
    const url = waiting2Download.dataset.url;
    if (!url) return alert('生成された音声がありません');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'gassaku.mp3';
    a.click();
  }

  // server time ping
  async function estimateServerOffset() {
    const rand = Math.random().toString(36).slice(2, 8);
    const pings = [];
    for (let i=0;i<6;i++){
      const t0 = Date.now();
      const tempRef = ref(db, `__serverTimeTest/${uid}_${rand}_${i}`);
      try {
        await set(tempRef, {ts: serverTimestamp()});
        const snap = await get(tempRef);
        const serverTs = snap.val() && snap.val().ts;
        const t1 = Date.now();
        if (serverTs) {
          const rtt = t1 - t0;
          const offset = serverTs - (t0 + rtt/2);
          pings.push(offset);
        }
      } catch(e) { console.warn('ping failed', e); }
      await new Promise(r => setTimeout(r, 50));
    }
    if (pings.length) {
      pings.sort((a,b)=>a-b);
      serverOffset = pings[Math.floor(pings.length/2)];
      console.log('serverOffset', serverOffset);
    } else serverOffset = 0;
  }

  // misc utils
  function getContrastYIQ(hexcolor){
    try {
      if (!hexcolor || !hexcolor.startsWith('#')) return '#fff';
      const r = parseInt(hexcolor.substr(1,2),16);
      const g = parseInt(hexcolor.substr(3,2),16);
      const b = parseInt(hexcolor.substr(5,2),16);
      const yiq = ((r*299)+(g*587)+(b*114))/1000;
      return (yiq >= 128) ? '#000' : '#fff';
    } catch(e){ return '#fff'; }
  }
  function adjustLaneHeight(){
    const h = Math.max(360, window.innerHeight * 0.62);
    laneEl.style.height = `${h}px`;
  }

  // WAV fallback (if lame unavailable)
  function audioBufferToWav(buffer, opt) {
    opt = opt || {};
    var numChannels = buffer.numberOfChannels;
    var sampleRate = buffer.sampleRate;
    var format = opt.float32 ? 3 : 1;
    var bitDepth = format === 3 ? 32 : 16;
    var result;
    if (numChannels === 2) result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
    else result = buffer.getChannelData(0);
    return encodeWAV(result, format, sampleRate, numChannels, bitDepth);
  }
  function interleave(inputL, inputR){
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);
    var index = 0, inputIndex = 0;
    while (index < length){ result[index++] = inputL[inputIndex]; result[index++] = inputR[inputIndex]; inputIndex++; }
    return result;
  }
  function encodeWAV(samples, format, sampleRate, numChannels, bitDepth){
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;
    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format === 3 ? 3 : 1, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    writeString(view, 36, 'data');
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) floatTo16BitPCM(view, 44, samples);
    else writeFloat32(view, 44, samples);
    return new Blob([buffer], { type: 'audio/wav' });
  }
  function floatTo16BitPCM(output, offset, input){
    for (var i = 0; i < input.length; i++, offset += 2){ var s = Math.max(-1, Math.min(1, input[i])); output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true); }
  }
  function writeFloat32(output, offset, input){
    for (var i = 0; i < input.length; i++, offset += 4){ output.setFloat32(offset, input[i], true); }
  }
  function writeString(view, offset, string){
    for (var i = 0; i < string.length; i++){ view.setUint8(offset + i, string.charCodeAt(i)); }
  }

  // End of script
  </script>
</body>
</html>
