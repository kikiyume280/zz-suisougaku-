<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>合作音ゲー（管理者合成版）</title>
  <link rel="icon" href="data:," />
  <style>
    body{font-family: system-ui, sans-serif; margin:0; padding:0; display:flex; flex-direction:column; min-height:100vh; background:#f5f5f7}
    #top{padding:12px; display:flex; gap:8px; align-items:center; background:#fff; border-bottom:1px solid #ddd}
    #statusBar{margin-left:12px; font-size:14px; color:#333}
    #bigStatus { font-size:28px; font-weight:800; color:#111; margin:12px 0; text-align:center; }
    #waiting,#waiting2,#game,#result{display:none; padding:12px}
    .role { padding:8px; border-radius:6px; margin:6px; display:inline-flex; gap:8px; align-items:center; min-width:160px; white-space:pre-line}
    .role .label { font-size:12px; color:#222; background:rgba(255,255,255,0.12); padding:2px 6px; border-radius:4px }
    #lane{position:relative; height:60vh; background:#000; color:white; overflow:hidden; border-radius:8px}
    .note{ position:absolute; left:50%; transform:translateX(-50%); width:80%; height:16px; border-radius:4px; text-align:center; line-height:16px; font-size:14px; opacity:0.95; transition:opacity 0.06s linear}
    #judgeLine{position:absolute; bottom:60px; left:0; right:0; height:8px; background:rgba(255,255,255,0.92); z-index:5}
    #topBalls{display:flex; gap:6px; margin-top:6px; flex-wrap:wrap}
    .ball{width:34px; height:34px; border-radius:50%; background:#666; display:flex; align-items:center; justify-content:center; color:white; font-size:12px}
    #controls{position:fixed; right:12px; bottom:12px; z-index:999}
    #rolesList{display:flex; flex-wrap:wrap; gap:8px; justify-content:center}
    #roleTitle{margin-bottom:8px}
    button{cursor:pointer}
    .small{font-size:12px; color:#666}
    input[type="text"]{padding:6px}
    #transientText{position:absolute; left:50%; transform:translateX(-50%); bottom:90px; font-size:28px; font-weight:700; color:#fff; text-shadow:0 0 6px #000; pointer-events:none; opacity:0; transition:opacity 0.12s linear}
    #countdown{position:absolute; left:50%; transform:translateX(-50%); bottom:20px; font-size:16px; color:#fff; opacity:0.95}
    #userInfo{font-size:13px; color:#333; margin-left:12px}
    #adminApply{margin-left:6px}
    #waiting2 .panel { background:#fff; padding:16px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.08); max-width:900px; margin:0 auto }
    #waiting2 .bigStatus { font-size:20px; margin-bottom:8px; text-align:center; font-weight:700; color:#222 }
    #waiting2 .small{ text-align:center; color:#666 }
  </style>
</head>
<body>
  <div id="top">
    <button id="joinBtn">参加</button>
    <div style="margin-left:auto; display:flex; align-items:center; gap:8px">
      <div class="small">運営パス</div>
      <input id="adminPw" placeholder="" style="width:110px; padding:6px"/>
      <button id="adminApply">決定</button>
      <div id="userInfo">未参加</div>
      <div id="statusBar">状態: <span id="stateText">--</span></div>
    </div>
  </div>

  <div id="waiting">
    <div id="bigStatus">セッション待機中</div>
    <div id="rolesList"></div>
    <div id="topBalls"></div>
    <div id="controls" style="text-align:center; margin-top:12px">
      <button id="startBtn" style="display:none">開始（運営）</button>
      <button id="adminReset" style="display:none">強制終了（運営）</button>
    </div>
  </div>

  <div id="waiting2">
    <div class="panel">
      <div class="bigStatus" id="waiting2Big">演奏終了 — 集計・合成中</div>
      <div id="waiting2Status" class="small">現在: --</div>
      <div style="margin-top:12px">
        <audio id="waiting2Audio" controls style="width:100%"></audio>
        <div style="margin-top:8px; text-align:center">
          <button id="waiting2Download" style="display:none">保存（MP3）</button>
          <button id="waiting2Back">戻る（待機へ）</button>
        </div>
      </div>
    </div>
  </div>

  <div id="game">
    <h3 id="roleTitle"></h3>
    <div id="lane">
      <div id="judgeLine"></div>
      <div id="transientText"></div>
      <div id="countdown"></div>
    </div>
    <p style="text-align:center">スペースキー／タップで判定（PERFECT: ±0.5s）</p>
  </div>

  <div id="result">
    <h3>完成！</h3>
    <audio id="finalAudio" controls></audio>
    <div style="margin-top:8px; text-align:center">
      <button id="downloadBtn">保存（MP3）</button>
      <button id="backBtn">戻る（待機へ）</button>
    </div>
  </div>

  <script type="module">
/* 既存の機能をなるべく壊さずに、以下を実装：
   - playersAtStart を start 時に保存 → 合成時の基準にする
   - 合成は運営(owner)のみが行う。mixLock で排他制御
   - 各プレイヤーの records は sessions/.../records/<uid> に配列で保存（到着順に依存しない）
   - 合成後は sessions/.../finalRecords と sessions/.../finalData に保存して全員に配布
   - クライアントは finalData を受け取ったら再生・保存・戻るができる
   - countdown 表示、ノーツの通過/消去ルールを改善
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getDatabase, ref, onValue, set, update, get, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-database.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

// ------------------ CONFIG（直接編集） ------------------
const CONFIG = {
  overrideAssets: true,
  assets: {
    "@": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/kyoku.mp3",
    "miss": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/miss.mp3",
    "A": {
      clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/A.mp3",
      color: "#FF6666",
      label: "シンバル",
      guideTimes: ["0:18.00", "0:25.56", "0:38.12","0:54.94","0:57.80"]
    },
    "B": {
      clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/B.mp3",
      color: "#66CCFF",
      label: "カスタネット",
      guideTimes: ["0:27.50","0:28.21","0:28.83","0:29.60","0:30.32","0:31.01","0:31.78","0:32.48","0:33.15","0:34.66","0:35.38","0:36.02","0:36.75","0:42.09","0:44.09","0:54.96","0:57.77"]
    },
     "C": {
      clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/C.mp3",
      color: "#2F1226",
      label: "ドラム",
      guideTimes: ["0:17.07", "0:20.02","0:21.78","0:22.57","0:22.37","0:23.37","0:24.80","0:25.19","0:33.91","0:34.66","0:35.30","0:36.09","0:36.78","0:49.61","0:50.44","0:51.31","0:52.13","0:52.94","0:53.75"]
    }
  },
  rolesOrder: ["A","B","C"]
};
// ---------------------------------------------------------------------

// Firebase config - ensure databaseURL is correct
const firebaseConfig = {
  apiKey: "AIzaSyBePhUfYinZ02-1BWbZvzV3IBwoAYh-kxE",
  authDomain: "suisougaku-bdcc0.firebaseapp.com",
  projectId: "suisougaku-bdcc0",
  databaseURL: "https://suisougaku-bdcc0-default-rtdb.firebaseio.com/",
  storageBucket: "suisougaku-bdcc0.appspot.com",
  messagingSenderId: "636001978886",
  appId: "1:636001978886:web:24e68f1ef5b66dc7fa5187",
  measurementId: "G-Y04PFJ9BQ6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

// DB refs
const sessionId = "session-proto-1";
const sessionRef = ref(db, `sessions/${sessionId}`);
const finalDataRef = ref(db, `sessions/${sessionId}/finalData`);
const finalRecordsRef = ref(db, `sessions/${sessionId}/finalRecords`);
const mixLockRef = ref(db, `sessions/${sessionId}/mixLock`);

let uid = null;
let userName = null;
let userRole = null;
let isAdmin = false;
let adminApplied = false;
let startServerTime = null;
let serverOffset = 0;
let assets = null;
let audioContext = null;
let baseAudioBuffer = null;
let roleAudioBuffer = null;
let missAudioBuffer = null;
let localClicks = [];
let currentSessionSnapshot = null;
let baseSourceNode = null;
let baseEndTimer = null;
let countdownInterval = null;

// DOM
const joinBtn = document.getElementById('joinBtn');
const startBtn = document.getElementById('startBtn');
const adminResetBtn = document.getElementById('adminReset');
const adminApplyBtn = document.getElementById('adminApply');
const adminPwInput = document.getElementById('adminPw');
const rolesListEl = document.getElementById('rolesList');
const waitingEl = document.getElementById('waiting');
const waiting2El = document.getElementById('waiting2');
const waiting2StatusEl = document.getElementById('waiting2Status');
const waiting2Audio = document.getElementById('waiting2Audio');
const waiting2Download = document.getElementById('waiting2Download');
const waiting2Back = document.getElementById('waiting2Back');
const gameEl = document.getElementById('game');
const resultEl = document.getElementById('result');
const roleTitleEl = document.getElementById('roleTitle');
const laneEl = document.getElementById('lane');
const topBallsEl = document.getElementById('topBalls');
const finalAudioEl = document.getElementById('finalAudio');
const downloadBtn = document.getElementById('downloadBtn');
const backBtn = document.getElementById('backBtn');
const transientTextEl = document.getElementById('transientText');
const countdownEl = document.getElementById('countdown');
const userInfoEl = document.getElementById('userInfo');
const stateTextEl = document.getElementById('stateText');
const bigStatusEl = document.getElementById('bigStatus');

// init
(async function init(){
  try {
    await signInAnonymously(auth);
    uid = auth.currentUser.uid;
    console.log('signed in uid=', uid);
  } catch (err) {
    console.error('auth error', err);
    alert('Firebase 匿名ログインに失敗しました。Console で Anonymous を有効にしてください。\n' + err.message);
  }

  joinBtn.addEventListener('click', joinFlow);
  startBtn.addEventListener('click', onStartClicked);
  adminResetBtn.addEventListener('click', onAdminReset);
  adminApplyBtn.addEventListener('click', onAdminApply);
  downloadBtn.addEventListener('click', onDownloadMP3);
  waiting2Download.addEventListener('click', onDownloadWaiting2MP3);
  waiting2Back.addEventListener('click', () => { waiting2El.style.display='none'; waitingEl.style.display='block'; });

  onValue(sessionRef, snapshot => {
    const v = snapshot.val();
    currentSessionSnapshot = v || {};
    if (CONFIG.overrideAssets || !(currentSessionSnapshot.assets && Object.keys(currentSessionSnapshot.assets).length)) {
      assets = normalizeConfigAssets(CONFIG.assets || {});
    } else {
      assets = normalizeConfigAssets(currentSessionSnapshot.assets || {});
    }
    startServerTime = currentSessionSnapshot.startServerTime || null;
    updateStateUI(currentSessionSnapshot.status || 'waiting');
    updateRolesView(currentSessionSnapshot);

    const status = currentSessionSnapshot.status || 'waiting';
    if (status === 'collecting' || status === 'compiling' || status === 'finished') {
      waiting2El.style.display = 'block';
      waitingEl.style.display = 'none';
      gameEl.style.display = 'none';
    } else if (status === 'running') {
      if (currentSessionSnapshot.players && currentSessionSnapshot.players[uid]) {
        userRole = currentSessionSnapshot.players[uid].role;
        showGame();
      } else {
        waitingEl.style.display = 'block';
        waiting2El.style.display = 'none';
        gameEl.style.display = 'none';
      }
    } else {
      waitingEl.style.display = 'block';
      waiting2El.style.display = 'none';
      gameEl.style.display = 'none';
    }
  });

  onValue(finalDataRef, snap => {
    const v = snap.val();
    if (v && v.dataUrl) {
      // ensure waiting2 visible
      waiting2El.style.display = 'block';
      waitingEl.style.display = 'none';
      gameEl.style.display = 'none';
      waiting2StatusEl.textContent = '合成完了';
      waiting2Audio.src = v.dataUrl;
      waiting2Download.style.display = 'inline-block';
      waiting2Download.dataset.url = v.dataUrl;
      finalAudioEl.src = v.dataUrl;
      downloadBtn.dataset.url = v.dataUrl;
    }
  });

  await estimateServerOffset();
  window.addEventListener('resize', adjustLaneHeight);
  adjustLaneHeight();
})();

// normalize & parse times & label
function normalizeConfigAssets(rawAssets) {
  const out = {};
  for (const k of Object.keys(rawAssets || {})) {
    if (k === '@' || k === 'miss') { out[k] = rawAssets[k]; continue; }
    const v = rawAssets[k] || {};
    out[k] = {
      clipUrl: v.clipUrl || v.url || null,
      color: v.color || '#777',
      label: v.label || '',
      guideTimes: (v.guideTimes || []).map(parseTimeToSeconds)
    };
  }
  if (rawAssets['@']) out['@'] = rawAssets['@'];
  if (rawAssets['miss']) out['miss'] = rawAssets['miss'];
  return out;
}
function parseTimeToSeconds(val) {
  if (val === null || val === undefined) return 0;
  if (typeof val === 'number') return val;
  const s = String(val).trim();
  if (!s) return 0;
  if (s.indexOf(':') === -1) {
    const f = parseFloat(s); return isFinite(f) ? f : 0;
  }
  const parts = s.split(':').map(p => p.trim());
  let seconds = 0;
  if (parts.length === 3) { const h=parseInt(parts[0])||0; const m=parseInt(parts[1])||0; const sec=parseFloat(parts[2].replace(',', '.'))||0; seconds=h*3600+m*60+sec; }
  else if (parts.length === 2) { const m=parseInt(parts[0])||0; const sec=parseFloat(parts[1].replace(',', '.'))||0; seconds=m*60+sec; }
  else seconds = parseFloat(parts[0].replace(',', '.'))||0;
  return seconds;
}

// UI / DB functions
function updateStateUI(status) {
  const map = { waiting:'待機中', running:'演奏中', collecting:'集計中', compiling:'合成中', finished:'完成' };
  stateTextEl.textContent = map[status] || status;
  bigStatusEl.textContent = map[status] ? `状態: ${map[status]}` : '状態: --';
  isAdmin = adminApplied;
  adminResetBtn.style.display = isAdmin ? 'inline-block' : 'none';
  startBtn.style.display = isAdmin ? 'inline-block' : 'none';
}

function updateRolesView(sessionData) {
  rolesListEl.innerHTML = '';
  const rolesOrder = sessionData.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
  (rolesOrder).forEach(role => {
    const info = assets && assets[role];
    const color = info?.color || '#777';
    const el = document.createElement('div');
    el.className = 'role';
    el.style.background = color;
    el.style.color = getContrastYIQ(color);
    const letter = document.createElement('div'); letter.textContent = role; letter.style.fontWeight='700';
    const label = document.createElement('div'); label.className='label'; label.textContent = (info && info.label) ? info.label : '';
    el.appendChild(letter); el.appendChild(label);
    const names = [];
    for (const [puid, pdata] of Object.entries(sessionData.players || {})) {
      if (pdata.role === role) names.push(pdata.name);
    }
    if (names.length) { const namesDiv = document.createElement('div'); namesDiv.textContent = names.join(', '); namesDiv.style.marginLeft='8px'; el.appendChild(namesDiv); }
    rolesListEl.appendChild(el);
  });

  if (sessionData.players && sessionData.players[uid]) {
    userInfoEl.textContent = `あなた: ${sessionData.players[uid].name} (${sessionData.players[uid].role})`;
    userRole = sessionData.players[uid].role;
  } else {
    userInfoEl.textContent = '未参加';
  }
}

async function joinFlow(){
  const name = prompt('名前を入力してください');
  if (!name) return;
  userName = name.trim() || '名無し';
  const snap = await get(sessionRef);
  const session = snap.val() || {};
  const players = session.players || {};
  const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
  const assigned = Object.values(players).map(p => p.role);
  let roleToAssign = null;
  for (const r of rolesOrder) { if (!assigned.includes(r)) { roleToAssign = r; break; } }
  if (!roleToAssign) roleToAssign = rolesOrder[assigned.length % rolesOrder.length];
  await set(ref(db, `sessions/${sessionId}/players/${uid}`), { name: userName, role: roleToAssign, joinedAt: Date.now() });
  userRole = roleToAssign;
  userInfoEl.textContent = `あなた: ${userName} (${userRole})`;
  waitingEl.style.display = 'block';
}

async function onAdminApply(){
  const val = adminPwInput.value;
  if (val === '1122') {
    adminApplied = true; isAdmin = true;
    // claim ownership if not present
    const snap = await get(ref(db, `sessions/${sessionId}/ownerUid`));
    if (!snap.exists()) {
      await set(ref(db, `sessions/${sessionId}/ownerUid`), uid);
    }
    updateStateUI(currentSessionSnapshot.status || 'waiting');
    alert('運営モードに切り替わりました');
  } else { alert('パスワードが違います'); }
}

// Start by admin: save playersAtStart (snapshot) and startServerTime. This provides expected UIDs for finalization.
async function onStartClicked(){
  // only owner allowed
  const ownerSnap = await get(ref(db, `sessions/${sessionId}/ownerUid`));
  const ownerUid = ownerSnap.exists() ? ownerSnap.val() : null;
  if (ownerUid && ownerUid !== uid) { alert('運営以外は開始できません'); return; }
  try {
    // snapshot players at start
    const playersSnap = await get(ref(db, `sessions/${sessionId}/players`));
    const playersObj = playersSnap.val() || {};
    // write startServerTime and playersAtStart
    await update(sessionRef, { status: 'running', startServerTime: serverTimestamp(), playersAtStart: playersObj });
    // ensure mixLock cleared
    await set(mixLockRef, null);
    // ensure finalData cleared
    await set(finalDataRef, null);
    await set(finalRecordsRef, null);
  } catch (e) {
    console.error('start failed', e);
    alert('開始に失敗しました。Console を確認してください。');
  }
}

async function onAdminReset(){
  if (!confirm('本当に強制終了してセッションの参加者/記録を初期化しますか？（assetsは維持されます）')) return;
  try {
    const keepAssets = currentSessionSnapshot.assets || CONFIG.assets || {};
    const payload = { status: 'waiting', assets: keepAssets, rolesOrder: currentSessionSnapshot.rolesOrder || CONFIG.rolesOrder || CONFIG.rolesOrder };
    await set(sessionRef, payload);
    await set(ref(db, `sessions/${sessionId}/players`), null);
    await set(ref(db, `sessions/${sessionId}/records`), null);
    await set(ref(db, `sessions/${sessionId}/realtimeActions`), null);
    await set(ref(db, `sessions/${sessionId}/startServerTime`), null);
    await set(ref(db, `sessions/${sessionId}/finalMeta`), null);
    await set(finalDataRef, null);
    await set(finalRecordsRef, null);
    await set(mixLockRef, null);
    alert('強制終了しました。参加者データと記録を削除しました。');
  } catch(e) {
    console.error('reset failed', e);
    alert('強制終了に失敗しました。Console を確認してください。');
  }
}

// showGame, load assets, schedule playback & countdown
function showGame(){
  waitingEl.style.display = 'none'; waiting2El.style.display='none'; gameEl.style.display = 'block';
  resultEl.style.display='none';
  roleTitleEl.textContent = `あなたの役割: ${userRole || '未割当'}`;
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  localClicks = [];
  loadAssetsAndStart();
  window.addEventListener('keydown', onKeyDown);
  laneEl.addEventListener('touchstart', onTouchStart, {passive:true});
}

function onKeyDown(e){ if (e.code === 'Space') { e.preventDefault(); recordLocalClick(); } }
function onTouchStart(e){ recordLocalClick(); }

async function loadAssetsAndStart(){
  if (!assets || !assets['@']) { alert('ベース曲(@)が設定されていません。'); return; }
  try { baseAudioBuffer = await fetchAndDecode(assets['@']); } catch(e){ console.error('base load error', e); alert('ベース曲読み込み失敗'); return; }
  if (assets['miss']) { try { missAudioBuffer = await fetchAndDecode(assets['miss']); } catch(e){ console.warn('miss load failed', e); } }
  const roleUrl = assets[userRole] && assets[userRole].clipUrl;
  if (roleUrl) { try { roleAudioBuffer = await fetchAndDecode(roleUrl); } catch(e){ console.warn('role clip load failed', e); } }

  // if startServerTime exists -> schedule; else wait for it then schedule
  if (startServerTime) { scheduleBasePlaybackAndEndHandler(); } else {
    const unsub = onValue(sessionRef, snap => {
      const v = snap.val() || {};
      if (v.startServerTime && v.status === 'running') {
        startServerTime = v.startServerTime;
        scheduleBasePlaybackAndEndHandler();
        unsub();
      }
    });
  }
  renderNotesForRole();
}

function scheduleBasePlaybackAndEndHandler(){
  if (!audioContext || !baseAudioBuffer || !startServerTime) return;
  // compute elapsed and schedule accordingly
  const nowClientMs = Date.now() + serverOffset;
  const elapsedMs = nowClientMs - startServerTime;
  const elapsedSec = Math.max(0, elapsedMs/1000);

  if (baseSourceNode) try { baseSourceNode.disconnect(); } catch(e) {}
  baseSourceNode = audioContext.createBufferSource();
  baseSourceNode.buffer = baseAudioBuffer;
  baseSourceNode.connect(audioContext.destination);

  // schedule start
  if (elapsedSec <= 0) baseSourceNode.start(audioContext.currentTime + (-elapsedSec), 0);
  else {
    if (elapsedSec >= baseAudioBuffer.duration) { onBaseEnded(); return; }
    else baseSourceNode.start(audioContext.currentTime, elapsedSec);
  }

  // start countdown UI until base starts (if start in future)
  if (elapsedSec < 0) startCountdown(Math.ceil(-elapsedSec/1000));
  else countdownEl.textContent = '';

  // schedule base end handler
  const remainingMs = (baseAudioBuffer.duration - elapsedSec) * 1000;
  if (baseEndTimer) clearTimeout(baseEndTimer);
  baseEndTimer = setTimeout(()=>{ onBaseEnded(); }, Math.max(0, remainingMs + 50));
}

function startCountdown(seconds) {
  if (countdownInterval) clearInterval(countdownInterval);
  let sec = seconds;
  countdownEl.textContent = `開始まで残り: ${sec}秒`;
  countdownInterval = setInterval(()=> {
    sec -= 1;
    if (sec <= 0) { countdownEl.textContent = ''; clearInterval(countdownInterval); countdownInterval = null; }
    else countdownEl.textContent = `開始まで残り: ${sec}秒`;
  }, 1000);
}

function renderNotesForRole(){
  laneEl.querySelectorAll('.note').forEach(n => n.remove());
  const times = (assets && assets[userRole] && assets[userRole].guideTimes) || [];
  const travelMs = 3000;
  const baseServerStartMs = startServerTime || (Date.now() + serverOffset);
  times.forEach((gtime, idx) => {
    const targetMs = baseServerStartMs + Math.round(gtime*1000);
    const appearAt = targetMs - travelMs;
    const div = document.createElement('div');
    div.className = 'note';
    div.dataset.guide = String(gtime);
    div.dataset.appearAt = String(appearAt);
    div.dataset.targetAt = String(targetMs);
    div.style.background = (assets[userRole] && assets[userRole].color) || '#444';
    div.style.color = getContrastYIQ(assets[userRole] && assets[userRole].color || '#444');
    laneEl.appendChild(div);

    const animate = () => {
      const t = Date.now() + serverOffset;
      const pct = (t - appearAt) / travelMs;
      const laneHeight = laneEl.clientHeight;
      const startY = laneHeight - 16;
      const endY = 60;
      if (pct >= 1.5) { div.style.opacity='0'; setTimeout(()=>div.remove(),300); return; }
      if (pct <= 0) { div.style.bottom = `${startY}px`; requestAnimationFrame(animate); }
      else { const y = startY - (startY - endY) * Math.min(pct,1); div.style.bottom = `${y}px`; requestAnimationFrame(animate); }
    };
    requestAnimationFrame(animate);
  });
}

// recording and per-note behavior
function recordLocalClick(){
  if (!startServerTime) { alert('まだ開始されていません'); return; }
  const clientNow = Date.now();
  const relativeMs = (clientNow + serverOffset) - startServerTime;
  const relativeSec = Math.max(0, relativeMs/1000);
  localClicks.push({ t: relativeSec });
  const res = evaluateHitAndHandleNote(relativeSec);
  showTransientText(res === 'perfect' ? 'PERFECT' : 'MISS', res === 'perfect' ? '#8ef27a' : '#ff6b6b');
  broadcastAction(res === 'perfect' ? 'perfect' : 'miss');
}

function evaluateHitAndHandleNote(relativeSec){
  const notes = Array.from(laneEl.querySelectorAll('.note'));
  if (!notes.length) return evaluateHit(relativeSec);
  let bestNote = null; let bestDiff = Infinity;
  for (const n of notes) {
    const guide = parseFloat(n.dataset.guide) || 0;
    const d = Math.abs(guide - relativeSec);
    if (d < bestDiff) { bestDiff = d; bestNote = n; }
  }
  if (!bestNote) return evaluateHit(relativeSec);
  const isPerfect = bestDiff <= 0.5;
  const appearAt = Number(bestNote.dataset.appearAt);
  const targetMs = Number(bestNote.dataset.targetAt);
  const travelMs = targetMs - appearAt;
  const t = Date.now() + serverOffset;
  const pct = (t - appearAt) / (travelMs || 1);

  if (isPerfect) {
    playRoleClipNow(); bestNote.remove(); return 'perfect';
  } else {
    if (pct > 1) bestNote.remove();
    playMissClipNow(); return 'miss';
  }
}
function evaluateHit(relativeSec){
  const times = (assets && assets[userRole] && assets[userRole].guideTimes) || [];
  let bestDiff = Infinity;
  for (const gt of times) { const d = Math.abs(gt - relativeSec); if (d < bestDiff) bestDiff = d; }
  return bestDiff <= 0.5 ? 'perfect' : 'miss';
}
async function playRoleClipNow(){
  try { if (!roleAudioBuffer && assets[userRole] && assets[userRole].clipUrl) roleAudioBuffer = await fetchAndDecode(assets[userRole].clipUrl);
    if (roleAudioBuffer && audioContext) { const src = audioContext.createBufferSource(); src.buffer = roleAudioBuffer; src.connect(audioContext.destination); src.start(); } }
  catch(e){ console.warn('playRoleClipNow failed', e); }
}
async function playMissClipNow(){
  try { if (!missAudioBuffer && assets['miss']) missAudioBuffer = await fetchAndDecode(assets['miss']);
    if (missAudioBuffer && audioContext) { const src = audioContext.createBufferSource(); src.buffer = missAudioBuffer; src.connect(audioContext.destination); src.start(); } }
  catch(e){ console.warn('playMissClipNow failed', e); }
}

async function broadcastAction(kind){
  try {
    await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), { kind, name: userName || uid, time: serverTimestamp() });
    setTimeout(async () => { try { await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), null); } catch(e){} }, 900);
  } catch(e) { console.warn(e); }
}
onValue(ref(db, `sessions/${sessionId}/realtimeActions`), snap => {
  const v = snap.val() || {}; topBallsEl.innerHTML = '';
  for (const [puid, data] of Object.entries(v)) { if (!data) continue; const b = document.createElement('div'); b.className='ball'; b.textContent = data.kind === 'perfect' ? 'P' : 'X'; topBallsEl.appendChild(b); }
});
function showTransientText(text, color){ transientTextEl.style.color = color || '#fff'; transientTextEl.textContent = text; transientTextEl.style.opacity = '1'; setTimeout(()=>{ transientTextEl.style.opacity='0'; },700); }

// base ended: each client sends its records to sessions/.../records/<uid>
// BUT mixing/compiling is only done by owner (acquires mixLock and executes)
async function onBaseEnded(){
  console.log('ベース曲が終了');
  try { await set(ref(db, `sessions/${sessionId}/records/${uid}`), localClicks); } catch(e) { console.warn('send records failed', e); }
  // show waiting2
  waiting2El.style.display = 'block'; waitingEl.style.display='none'; gameEl.style.display='none';
  waiting2StatusEl.textContent = '全員の記録を集計中…';
  // if current user is owner, start monitoring and try to acquire mix lock to do mixing
  const ownerSnap = await get(ref(db, `sessions/${sessionId}/ownerUid`));
  const ownerUid = ownerSnap.exists() ? ownerSnap.val() : null;
  if (ownerUid === uid) {
    // Owner will attempt to perform mixing: wait for all records OR timeout -> acquire mixLock -> mix -> write finalRecords/finalData
    await ownerMonitorAndMix();
  } else {
    // non-owner clients just wait for finalData (listening is set up earlier)
  }
}

// Owner-only: monitor records arrival, acquire lock, mix once
async function ownerMonitorAndMix(){
  // get playersAtStart to determine expected uids
  const snap = await get(sessionRef); const session = snap.val() || {};
  const playersAtStart = session.playersAtStart || session.players || {};
  const expectedUids = Object.keys(playersAtStart);
  // include auto roles UIDs too
  const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
  for (const r of rolesOrder) {
    const assigned = Object.values(playersAtStart || {}).some(p => p.role === r);
    if (!assigned) expectedUids.push(`__auto_${r}`);
  }

  const TIMEOUT_MS = 20000; // owner waits this long for missing records before proceeding
  const startWait = Date.now();
  while (true) {
    const recSnap = await get(ref(db, `sessions/${sessionId}/records`));
    const records = recSnap.val() || {};
    const have = Object.keys(records || {});
    const missing = expectedUids.filter(e => !have.includes(e));
    if (missing.length === 0) {
      // try acquire mix lock
      const locked = await attemptAcquireMixLock();
      if (locked) {
        await doMixAndPublish(records, session, playersAtStart);
        break;
      } else {
        // someone else holds lock: wait for finalData to appear
        const finalSnap = await get(finalDataRef);
        if (finalSnap.exists()) break;
        await new Promise(r=>setTimeout(r,600));
      }
    } else {
      if (Date.now() - startWait > TIMEOUT_MS) {
        // timeout -> synthesize missing auto records locally and proceed
        // ensure missing autos are created locally in records object
        for (const m of missing) {
          if (m.startsWith('__auto_')) {
            const r = m.replace('__auto_','');
            const guideTimes = (assets[r] && assets[r].guideTimes) || [];
            records[m] = guideTimes.map(t => ({ t }));
          } else {
            // no data for participant -> treat as empty array
            records[m] = [];
          }
        }
        const locked = await attemptAcquireMixLock();
        if (locked) {
          await doMixAndPublish(records, session, playersAtStart);
          break;
        } else {
          // someone else may have published; break
          const finalSnap = await get(finalDataRef);
          if (finalSnap.exists()) break;
          await new Promise(r=>setTimeout(r,600));
        }
      } else {
        await new Promise(r=>setTimeout(r,600));
      }
    }
  }
}

// attempt to acquire mix lock via transaction; returns true if acquired
async function attemptAcquireMixLock() {
  try {
    const lockRef = mixLockRef;
    const res = await runTransaction(lockRef, current => {
      if (current === null) return uid; // claim
      return; // abort
    });
    return res.committed && res.snapshot.val() === uid;
  } catch(e) {
    console.warn('mix lock transaction failed', e);
    return false;
  }
}

// perform mixing (owner). records is object uid->array of {t}, session and playersAtStart provided
async function doMixAndPublish(records, session, playersAtStart) {
  try {
    // ensure autos: for each role with no player in playersAtStart, already filled earlier or fill now
    const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
    for (const r of rolesOrder) {
      const assigned = Object.values(playersAtStart || {}).some(p => p.role === r);
      const autoUid = `__auto_${r}`;
      if (!assigned && !(records && records[autoUid])) {
        const guideTimes = (assets[r] && assets[r].guideTimes) || [];
        records[autoUid] = guideTimes.map(t => ({ t }));
      }
    }

    // Build finalRecords structure: copy records (uid -> { role, times })
    const finalRecords = {};
    for (const [puid, arr] of Object.entries(records || {})) {
      const role = (playersAtStart && playersAtStart[puid] && playersAtStart[puid].role) || (puid.startsWith('__auto_') ? puid.replace('__auto_','') : (session.players && session.players[puid] && session.players[puid].role) || null);
      finalRecords[puid] = { role: role, times: Array.isArray(arr) ? arr.map(x=>x.t||0) : [] };
    }

    // Write finalRecords to DB (for later re-edit / re-mix)
    await set(finalRecordsRef, finalRecords);

    // Now do audio mixing in owner client (OfflineAudioContext)
    if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
    if (!baseAudioBuffer) baseAudioBuffer = await fetchAndDecode(assets['@']);

    let maxT = baseAudioBuffer.duration;
    for (const fr of Object.values(finalRecords)) for (const t of fr.times) if (t > maxT) maxT = t;
    const sampleRate = 44100;
    const off = new OfflineAudioContext(2, Math.ceil((maxT + 2) * sampleRate), sampleRate);

    // base
    const baseSrc = off.createBufferSource(); baseSrc.buffer = baseAudioBuffer; baseSrc.connect(off.destination); baseSrc.start(0);

    // schedule each uid's clip for each time
    for (const [puid, rec] of Object.entries(finalRecords)) {
      const role = rec.role;
      const times = rec.times || [];
      const clipUrl = assets[role] && assets[role].clipUrl;
      if (!clipUrl) continue;
      try {
        const clipBuf = await fetchAndDecode(clipUrl);
        for (const t of times) {
          const src = off.createBufferSource(); src.buffer = clipBuf; src.connect(off.destination); src.start(t);
        }
      } catch(e){ console.warn('clip load failed for', role, e); continue; }
    }

    // render and encode (use wav if lame not available)
    const rendered = await off.startRendering();
    // try lamejs
    try { await loadLameJs(); } catch(e){ console.warn('lame load failed', e); }
    let blob;
    if (typeof lamejs !== 'undefined') blob = audioBufferToMp3(rendered);
    else blob = audioBufferToWav(rendered);

    const dataUrl = await blobToDataURL(blob);

    // Publish finalData (only if not already published)
    const curFinalSnap = await get(finalDataRef);
    if (!curFinalSnap.exists()) {
      await set(finalDataRef, { dataUrl, generatedBy: uid, generatedAt: serverTimestamp() });
      // also write finalMeta
      await set(ref(db, `sessions/${sessionId}/finalMeta`), { generatedBy: uid, generatedAt: serverTimestamp(), playerCount: Object.keys(finalRecords).length });
    }
  } catch(e) {
    console.error('doMixAndPublish failed', e);
  } finally {
    // release lock
    try { await set(mixLockRef, null); } catch(e){ console.warn('release lock failed', e); }
  }
}

// MP3 encoding helpers (lamejs)
let lameLoaded=false;
async function loadLameJs(){ if (lameLoaded) return; return new Promise((resolve, reject)=>{ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js'; s.onload=()=>{lameLoaded=true; resolve();}; s.onerror=(e)=>{console.warn('lame load failed',e); reject(e);}; document.head.appendChild(s); }); }
function audioBufferToMp3(audioBuffer){
  if (typeof lamejs === 'undefined') return audioBufferToWav(audioBuffer);
  const left = audioBuffer.getChannelData(0);
  const right = audioBuffer.numberOfChannels>1 ? audioBuffer.getChannelData(1) : left;
  const samples = interleaveFloat32(left,right);
  const mp3encoder = new lamejs.Mp3Encoder(2, audioBuffer.sampleRate, 128);
  const mp3Data=[]; const sampleBlockSize=1152;
  let idx=0;
  while(idx < samples.length){
    const leftChunk=[]; const rightChunk=[];
    for(let i=0;i<sampleBlockSize && idx < samples.length;i+=2){ leftChunk.push(samples[idx]); rightChunk.push(samples[idx+1]); idx+=2; }
    const left16 = floatTo16BitPCMArray(leftChunk); const right16 = floatTo16BitPCMArray(rightChunk);
    const mp3buf = mp3encoder.encodeBuffer(left16,right16); if (mp3buf.length>0) mp3Data.push(mp3buf);
  }
  const mp3buf = mp3encoder.flush(); if (mp3buf.length>0) mp3Data.push(mp3buf);
  return new Blob(mp3Data,{type:'audio/mp3'});
}
function interleaveFloat32(left,right){ const length=left.length+right.length; const result=new Float32Array(length); let index=0,inputIndex=0; while(inputIndex<left.length){ result[index++]=left[inputIndex]; result[index++]=right[inputIndex]; inputIndex++; } return result; }
function floatTo16BitPCMArray(float32Array){ const out=new Int16Array(float32Array.length); for(let i=0;i<float32Array.length;i++){ let s=Math.max(-1,Math.min(1,float32Array[i])); out[i]=s<0? s*0x8000 : s*0x7FFF; } return out; }

// fetch & decode / blob->dataURL / wav fallback
async function fetchAndDecode(url){ const res = await fetch(url); if(!res.ok) throw new Error('fetch failed: '+res.status); const ab = await res.arrayBuffer(); if(!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)(); return await audioContext.decodeAudioData(ab); }
function blobToDataURL(blob){ return new Promise(resolve=>{ const fr=new FileReader(); fr.onload=()=>resolve(fr.result); fr.readAsDataURL(blob); }); }
function audioBufferToWav(buffer,opt){ opt=opt||{}; var numChannels=buffer.numberOfChannels; var sampleRate=buffer.sampleRate; var format=opt.float32?3:1; var bitDepth=format===3?32:16; var result; if(numChannels===2) result=interleave(buffer.getChannelData(0),buffer.getChannelData(1)); else result=buffer.getChannelData(0); return encodeWAV(result,format,sampleRate,numChannels,bitDepth); }
function encodeWAV(samples,format,sampleRate,numChannels,bitDepth){ var bytesPerSample=bitDepth/8; var blockAlign=numChannels*bytesPerSample; var buffer=new ArrayBuffer(44 + samples.length*bytesPerSample); var view=new DataView(buffer); writeString(view,0,'RIFF'); view.setUint32(4,36 + samples.length*bytesPerSample,true); writeString(view,8,'WAVE'); writeString(view,12,'fmt '); view.setUint32(16,16,true); view.setUint16(20,format===3?3:1,true); view.setUint16(22,numChannels,true); view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*blockAlign,true); view.setUint16(32,blockAlign,true); view.setUint16(34,bitDepth,true); writeString(view,36,'data'); view.setUint32(40,samples.length*bytesPerSample,true); if(format===1) floatTo16BitPCM(view,44,samples); else writeFloat32(view,44,samples); return new Blob([buffer],{type:'audio/wav'}); }
function writeString(view,offset,string){ for(var i=0;i<string.length;i++) view.setUint8(offset+i,string.charCodeAt(i)); }
function floatTo16BitPCM(output,offset,input){ for(var i=0;i<input.length;i++,offset+=2){ var s=Math.max(-1,Math.min(1,input[i])); output.setInt16(offset,s<0? s*0x8000 : s*0x7FFF,true); } }

// download handlers
function onDownloadMP3(){ const url = downloadBtn.dataset.url; if(!url) return alert('生成された音声がありません'); const a=document.createElement('a'); a.href=url; a.download='gassaku.mp3'; a.click(); }
function onDownloadWaiting2MP3(){ const url = waiting2Download.dataset.url; if(!url) return alert('生成された音声がありません'); const a=document.createElement('a'); a.href=url; a.download='gassaku.mp3'; a.click(); }

// server time ping
async function estimateServerOffset(){ const rand=Math.random().toString(36).slice(2,8); const pings=[]; for(let i=0;i<6;i++){ const t0=Date.now(); const tempRef = ref(db, `__serverTimeTest/${uid}_${rand}_${i}`); try{ await set(tempRef,{ts:serverTimestamp()}); const snap = await get(tempRef); const serverTs = snap.val() && snap.val().ts; const t1=Date.now(); if(serverTs){ const rtt = t1 - t0; const offset = serverTs - (t0 + rtt/2); pings.push(offset); } } catch(e){ console.warn('ping failed', e); } await new Promise(r=>setTimeout(r,50)); } if(pings.length){ pings.sort((a,b)=>a-b); serverOffset = pings[Math.floor(pings.length/2)]; console.log('serverOffset', serverOffset); } else serverOffset = 0; }

// misc
function getContrastYIQ(hexcolor){ try{ if(!hexcolor||!hexcolor.startsWith('#')) return '#fff'; const r=parseInt(hexcolor.substr(1,2),16); const g=parseInt(hexcolor.substr(3,2),16); const b=parseInt(hexcolor.substr(5,2),16); const yiq = ((r*299)+(g*587)+(b*114))/1000; return (yiq >= 128) ? '#000' : '#fff'; } catch(e){ return '#fff'; } }
function adjustLaneHeight(){ const h = Math.max(360, window.innerHeight * 0.62); laneEl.style.height = `${h}px`; }

  </script>
</body>
</html>
