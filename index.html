<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>合作音ゲー</title>
  <link rel="icon" href="data:," />
  <style>
    body{font-family: system-ui, sans-serif; margin:0; padding:0; display:flex; flex-direction:column; min-height:100vh; background:#f5f5f7}
    #top{padding:12px; display:flex; gap:8px; align-items:center; background:#fff; border-bottom:1px solid #ddd}
    #statusBar{margin-left:12px; font-size:14px; color:#333}
    #bigStatus { font-size:28px; font-weight:800; color:#111; margin:12px 0; text-align:center; }
    #waiting,#waiting2,#game,#result{display:none; padding:12px}
    .role { padding:8px; border-radius:6px; margin:6px; display:inline-flex; gap:8px; align-items:center; min-width:160px; white-space:pre-line}
    .role .label { font-size:12px; color:#222; background:rgba(255,255,255,0.12); padding:2px 6px; border-radius:4px }
    #lane{position:relative; height:60vh; background:#000; color:white; overflow:hidden; border-radius:8px}
    .note{ position:absolute; left:50%; transform:translateX(-50%); width:80%; height:16px; border-radius:4px; text-align:center; line-height:16px; font-size:14px; opacity:0.95; transition:opacity 0.06s linear}
    #judgeLine{position:absolute; bottom:60px; left:0; right:0; height:8px; background:rgba(255,255,255,0.92); z-index:5}
    #topBalls{display:flex; gap:6px; margin-top:6px; flex-wrap:wrap}
    .ball{width:34px; height:34px; border-radius:50%; background:#666; display:flex; align-items:center; justify-content:center; color:white; font-size:12px}
    #controls{position:fixed; right:12px; bottom:12px; z-index:999}
    #rolesList{display:flex; flex-wrap:wrap; gap:8px; justify-content:center}
    #roleTitle{margin-bottom:8px}
    button{cursor:pointer}
    .small{font-size:12px; color:#666}
    input[type="text"]{padding:6px}
    #transientText{position:absolute; left:50%; transform:translateX(-50%); bottom:90px; font-size:28px; font-weight:700; color:#fff; text-shadow:0 0 6px #000; pointer-events:none; opacity:0; transition:opacity 0.12s linear}
    #countdown{position:absolute; left:16px; top:16px; color:#fff; background:rgba(0,0,0,0.45); padding:6px 10px; border-radius:6px; font-weight:700}
    #userInfo{font-size:13px; color:#333; margin-left:12px}
    #adminApply{margin-left:6px}
    #waiting2 .panel { background:#fff; padding:16px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.08); max-width:900px; margin:0 auto }
    #waiting2 .bigStatus { font-size:20px; margin-bottom:8px; text-align:center; font-weight:700; color:#222 }
    #waiting2 .small{ text-align:center; color:#666 }
  </style>
</head>
<body>
  <div id="top">
    <button id="joinBtn">参加</button>
    <div style="margin-left:auto; display:flex; align-items:center; gap:8px">
      <div class="small">運営パス</div>
      <input id="adminPw" placeholder="" style="width:110px; padding:6px"/>
      <button id="adminApply">決定</button>
      <div id="userInfo">未参加</div>
      <div id="statusBar">状態: <span id="stateText">--</span></div>
    </div>
  </div>

  <div id="waiting">
    <div id="bigStatus">セッション待機中</div>
    <div id="rolesList"></div>
    <div id="topBalls"></div>
    <div id="controls" style="text-align:center; margin-top:12px">
      <button id="startBtn" style="display:none">開始（運営）</button>
      <button id="adminReset" style="display:none">強制終了（運営）</button>
    </div>
  </div>

  <div id="waiting2">
    <div class="panel">
      <div class="bigStatus" id="waiting2Big">演奏終了 — 集計・合成中</div>
      <div id="waiting2Status" class="small">現在: --</div>
      <div style="margin-top:12px">
        <audio id="waiting2Audio" controls style="width:100%"></audio>
        <div style="margin-top:8px; text-align:center">
          <button id="waiting2Download" style="display:none">保存（MP3）</button>
          <button id="waiting2Back">戻る（待機へ）</button>
        </div>
      </div>
    </div>
  </div>

  <div id="game">
    <h3 id="roleTitle"></h3>
    <div id="lane">
      <div id="judgeLine"></div>
      <div id="transientText"></div>
      <div id="countdown" style="display:none"></div>
    </div>
    <p style="text-align:center">スペースキー／タップで判定（PERFECT: ±0.5s）</p>
  </div>

  <div id="result">
    <h3>完成！</h3>
    <audio id="finalAudio" controls></audio>
    <div style="margin-top:8px; text-align:center">
      <button id="downloadBtn">保存（MP3）</button>
      <button id="backBtn">戻る（待機へ）</button>
    </div>
  </div>

  <script type="module">
/* =========================
   CONFIG (編集はここだけでOK)
   ========================= */
const CONFIG = {
  overrideAssets: true,
  assets: {
    "@": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/kyoku.mp3",
    "miss": "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/miss.mp3",
    "A": {
      clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/A.mp3",
      color: "#FF6666",
      label: "シンバル",
      guideTimes: ["0:18.00", "0:25.56", "0:38.12","0:54.94","0:57.80"]
    },
    "B": {
      clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/B.mp3",
      color: "#66CCFF",
      label: "カスタネット",
      guideTimes: ["0:27.50","0:28.21","0:28.83","0:29.60","0:30.32","0:31.01","0:31.78","0:32.48","0:33.15","0:34.66","0:35.38","0:36.02","0:36.75","0:42.09","0:44.09","0:54.96","0:57.77"]
    },
 
    "C": {
      clipUrl: "https://raw.githubusercontent.com/kikiyume280/zz-suisougaku-/main/C.mp3",
      color: "#2F1226",
      label: "ドラム",
      guideTimes: ["0:17.07","0:20.02","0:21.78","0:22.57","0:22.37","0:23.37","0:24.80","0:25.19","0:33.91","0:34.66","0:35.30","0:36.09","0:36.78","0:49.61","0:50.44","0:51.31","0:52.13","0:52.94","0:53.75"]
    }
  },
  rolesOrder: ["A","B","C"]
};
/* ========================= end CONFIG ========================= */

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
import { getDatabase, ref, onValue, set, update, get, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-database.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyBePhUfYinZ02-1BWbZvzV3IBwoAYh-kxE",
  authDomain: "suisougaku-bdcc0.firebaseapp.com",
  projectId: "suisougaku-bdcc0",
  databaseURL: "https://suisougaku-bdcc0-default-rtdb.firebaseio.com/",
  storageBucket: "suisougaku-bdcc0.appspot.com",
  messagingSenderId: "636001978886",
  appId: "1:636001978886:web:24e68f1ef5b66dc7fa5187",
  measurementId: "G-Y04PFJ9BQ6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

const sessionId = "session-proto-1";
const sessionRef = ref(db, `sessions/${sessionId}`);
const finalDataRef = ref(db, `sessions/${sessionId}/finalData`);
const finalRecordsRef = ref(db, `sessions/${sessionId}/finalRecords`);

let uid = null;
let userName = null;
let userRole = null;
let isAdmin = false;
let adminApplied = false;
let startServerTime = null;
let serverOffset = 0;
let assets = null;
let audioContext = null;
let baseAudioBuffer = null;
let roleAudioBuffer = null;
let missAudioBuffer = null;
let localClicks = [];
let currentSessionSnapshot = null;
let baseSourceNode = null;
let baseEndTimer = null;

const joinBtn = document.getElementById('joinBtn');
const startBtn = document.getElementById('startBtn');
const adminResetBtn = document.getElementById('adminReset');
const adminApplyBtn = document.getElementById('adminApply');
const adminPwInput = document.getElementById('adminPw');
const rolesListEl = document.getElementById('rolesList');
const waitingEl = document.getElementById('waiting');
const waiting2El = document.getElementById('waiting2');
const waiting2StatusEl = document.getElementById('waiting2Status');
const waiting2Audio = document.getElementById('waiting2Audio');
const waiting2Download = document.getElementById('waiting2Download');
const waiting2Back = document.getElementById('waiting2Back');
const gameEl = document.getElementById('game');
const resultEl = document.getElementById('result');
const roleTitleEl = document.getElementById('roleTitle');
const laneEl = document.getElementById('lane');
const topBallsEl = document.getElementById('topBalls');
const finalAudioEl = document.getElementById('finalAudio');
const downloadBtn = document.getElementById('downloadBtn');
const backBtn = document.getElementById('backBtn');
const transientTextEl = document.getElementById('transientText');
const userInfoEl = document.getElementById('userInfo');
const stateTextEl = document.getElementById('stateText');
const bigStatusEl = document.getElementById('bigStatus');
const countdownEl = document.getElementById('countdown');

(async function init(){
  try {
    await signInAnonymously(auth);
    uid = auth.currentUser.uid;
    console.log('signed in uid=', uid);
  } catch (err) {
    console.error('auth error', err);
    alert('Firebase 匿名ログインに失敗しました。Console で Anonymous を有効にしてください。\n' + err.message);
  }

  joinBtn.addEventListener('click', joinFlow);
  startBtn.addEventListener('click', onStartClicked);
  adminResetBtn.addEventListener('click', onAdminReset);
  adminApplyBtn.addEventListener('click', onAdminApply);
  downloadBtn.addEventListener('click', onDownloadMP3);
  waiting2Download.addEventListener('click', onDownloadWaiting2MP3);
  waiting2Back.addEventListener('click', () => { waiting2El.style.display='none'; waitingEl.style.display='block'; });

  onValue(sessionRef, snapshot => {
    const v = snapshot.val();
    currentSessionSnapshot = v || {};
    if (CONFIG.overrideAssets || !(currentSessionSnapshot.assets && Object.keys(currentSessionSnapshot.assets).length)) {
      assets = normalizeConfigAssets(CONFIG.assets || {});
    } else {
      assets = normalizeConfigAssets(currentSessionSnapshot.assets || {});
    }
    startServerTime = currentSessionSnapshot.startServerTime || null;
    updateStateUI(currentSessionSnapshot.status || 'waiting');
    updateRolesView(currentSessionSnapshot);

    const status = currentSessionSnapshot.status || 'waiting';
    if (status === 'collecting' || status === 'compiling' || status === 'finished') {
      waiting2El.style.display = 'block';
      waitingEl.style.display = 'none';
      gameEl.style.display = 'none';
    } else if (status === 'running') {
      if (currentSessionSnapshot.players && currentSessionSnapshot.players[uid]) {
        userRole = currentSessionSnapshot.players[uid].role;
        showGame();
      } else {
        waitingEl.style.display = 'block';
        waiting2El.style.display = 'none';
        gameEl.style.display = 'none';
      }
    } else {
      waitingEl.style.display = 'block';
      waiting2El.style.display = 'none';
      gameEl.style.display = 'none';
    }
  });

  onValue(finalDataRef, snap => {
    const v = snap.val();
    if (v && v.dataUrl) {
      waiting2El.style.display = 'block';
      waitingEl.style.display = 'none';
      gameEl.style.display = 'none';
      waiting2StatusEl.textContent = '合成完了';
      waiting2Audio.src = v.dataUrl;
      waiting2Download.style.display = 'inline-block';
      waiting2Download.dataset.url = v.dataUrl;
      finalAudioEl.src = v.dataUrl;
      downloadBtn.dataset.url = v.dataUrl;
    }
  });

  await estimateServerOffset();
  window.addEventListener('resize', adjustLaneHeight);
  adjustLaneHeight();
})();

function normalizeConfigAssets(rawAssets) {
  const out = {};
  for (const k of Object.keys(rawAssets || {})) {
    if (k === '@' || k === 'miss') { out[k] = rawAssets[k]; continue; }
    const v = rawAssets[k] || {};
    out[k] = {
      clipUrl: v.clipUrl || v.url || null,
      color: v.color || '#777',
      label: v.label || '',
      guideTimes: (v.guideTimes || []).map(parseTimeToSeconds)
    };
  }
  if (rawAssets['@']) out['@'] = rawAssets['@'];
  if (rawAssets['miss']) out['miss'] = rawAssets['miss'];
  return out;
}
function parseTimeToSeconds(val) {
  if (val === null || val === undefined) return 0;
  if (typeof val === 'number') return val;
  const s = String(val).trim();
  if (!s) return 0;
  if (s.indexOf(':') === -1) {
    const f = parseFloat(s);
    return isFinite(f) ? f : 0;
  }
  const parts = s.split(':').map(p => p.trim());
  let seconds = 0;
  if (parts.length === 3) {
    const h = parseInt(parts[0]) || 0;
    const m = parseInt(parts[1]) || 0;
    const sec = parseFloat(parts[2].replace(',', '.')) || 0;
    seconds = h*3600 + m*60 + sec;
  } else if (parts.length === 2) {
    const m = parseInt(parts[0]) || 0;
    const sec = parseFloat(parts[1].replace(',', '.')) || 0;
    seconds = m*60 + sec;
  } else {
    seconds = parseFloat(parts[0].replace(',', '.')) || 0;
  }
  return seconds;
}

function updateStateUI(status) {
  const map = { waiting:'待機中', running:'演奏中', collecting:'集計中', compiling:'合成中', finished:'完成' };
  stateTextEl.textContent = map[status] || status;
  bigStatusEl.textContent = map[status] ? `状態: ${map[status]}` : '状態: --';
  isAdmin = adminApplied;
  adminResetBtn.style.display = isAdmin ? 'inline-block' : 'none';
  startBtn.style.display = isAdmin ? 'inline-block' : 'none';
}

function updateRolesView(sessionData) {
  rolesListEl.innerHTML = '';
  const rolesOrder = sessionData.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
  (rolesOrder).forEach(role => {
    const info = assets && assets[role];
    const color = info?.color || '#777';
    const el = document.createElement('div');
    el.className = 'role';
    el.style.background = color;
    el.style.color = getContrastYIQ(color);
    const letter = document.createElement('div'); letter.textContent = role; letter.style.fontWeight='700';
    const label = document.createElement('div'); label.className='label'; label.textContent = (info && info.label) ? info.label : '';
    el.appendChild(letter); el.appendChild(label);
    const names = [];
    for (const [puid, pdata] of Object.entries(sessionData.players || {})) {
      if (pdata.role === role) names.push(pdata.name);
    }
    if (names.length) {
      const namesDiv = document.createElement('div');
      namesDiv.textContent = names.join(', ');
      namesDiv.style.marginLeft = '8px';
      el.appendChild(namesDiv);
    }
    rolesListEl.appendChild(el);
  });

  if (sessionData.players && sessionData.players[uid]) {
    userInfoEl.textContent = `あなた: ${sessionData.players[uid].name} (${sessionData.players[uid].role})`;
    userRole = sessionData.players[uid].role;
  } else {
    userInfoEl.textContent = '未参加';
  }
}

async function joinFlow(){
  const name = prompt('名前を入力してください');
  if (!name) return;
  userName = name.trim() || '名無し';
  const snap = await get(sessionRef);
  const session = snap.val() || {};
  const players = session.players || {};
  const rolesOrder = session.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
  const assigned = Object.values(players).map(p => p.role);
  let roleToAssign = null;
  for (const r of rolesOrder) { if (!assigned.includes(r)) { roleToAssign = r; break; } }
  if (!roleToAssign) roleToAssign = rolesOrder[assigned.length % rolesOrder.length];
  await set(ref(db, `sessions/${sessionId}/players/${uid}`), { name: userName, role: roleToAssign, joinedAt: Date.now() });
  userRole = roleToAssign;
  userInfoEl.textContent = `あなた: ${userName} (${userRole})`;
  waitingEl.style.display = 'block';
}

async function onAdminApply(){
  const val = adminPwInput.value;
  if (val === '1122') {
    adminApplied = true; isAdmin = true;
    // set ownerUid in DB if not set to make mixing authority explicit
    const snap = await get(sessionRef);
    const session = snap.val() || {};
    if (!session.ownerUid) {
      try { await update(sessionRef, { ownerUid: uid }); } catch(e){ console.warn('owner set failed', e); }
    }
    updateStateUI(currentSessionSnapshot.status || 'waiting');
    alert('運営モードに切り替わりました');
  } else alert('パスワードが違います');
}

async function onStartClicked(){
  if (!isAdmin) { alert('運営パスが必要です'); return; }
  try {
    // snapshot players at start so expected set is fixed
    const snap = await get(sessionRef);
    const session = snap.val() || {};
    const players = session.players || {};
    // playersSnapshot: uid-> {name, role}
    const playersSnapshot = {};
    for (const [puid, pdata] of Object.entries(players)) playersSnapshot[puid] = { name: pdata.name, role: pdata.role };
    // set ownerUid if not set
    const ownerUid = session.ownerUid || uid;
    await update(sessionRef, { status: 'running', startServerTime: serverTimestamp(), ownerUid, playersSnapshot });
    // auto-records for empty roles are optional (we still create __auto_* records later for mixing)
    await update(sessionRef, { finalData: null, finalRecords: null });
  } catch (e) {
    console.error('start failed', e);
    alert('開始に失敗しました。Console を確認してください。');
  }
}

async function onAdminReset(){
  if (!confirm('本当に強制終了してセッションの参加者/記録を初期化しますか？（assetsは維持されます）')) return;
  try {
    const keepAssets = currentSessionSnapshot.assets || CONFIG.assets || {};
    const payload = { status: 'waiting', assets: keepAssets, rolesOrder: currentSessionSnapshot.rolesOrder || CONFIG.rolesOrder || CONFIG.rolesOrder, ownerUid: null, playersSnapshot:null };
    await set(sessionRef, payload);
    await set(ref(db, `sessions/${sessionId}/players`), null);
    await set(ref(db, `sessions/${sessionId}/records`), null);
    await set(ref(db, `sessions/${sessionId}/realtimeActions`), null);
    await set(ref(db, `sessions/${sessionId}/startServerTime`), null);
    await set(ref(db, `sessions/${sessionId}/finalData`), null);
    await set(ref(db, `sessions/${sessionId}/finalRecords`), null);
    alert('強制終了しました。参加者データと記録を削除しました。');
  } catch(e) {
    console.error('reset failed', e);
    alert('強制終了に失敗しました。Console を確認してください。');
  }
}

function showGame(){
  waitingEl.style.display = 'none';
  waiting2El.style.display = 'none';
  gameEl.style.display = 'block';
  resultEl.style.display = 'none';
  roleTitleEl.textContent = `あなたの役割: ${userRole || '未割当'}`;
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  localClicks = [];
  loadAssetsAndStart();
  window.addEventListener('keydown', onKeyDown);
  laneEl.addEventListener('touchstart', onTouchStart, {passive:true});
}

function onKeyDown(e){
  if (e.code === 'Space') { e.preventDefault(); recordLocalClick(); }
}
function onTouchStart() { recordLocalClick(); }

async function loadAssetsAndStart(){
  if (!assets || !assets['@']) { alert('ベース曲(@)が設定されていません。'); return; }
  try { baseAudioBuffer = await fetchAndDecode(assets['@']); } catch(e){ console.error('base load error', e); alert('ベース曲読み込み失敗'); return; }
  if (assets['miss']) { try { missAudioBuffer = await fetchAndDecode(assets['miss']); } catch(e){ console.warn('miss load failed', e); } }
  const roleUrl = assets[userRole] && assets[userRole].clipUrl;
  if (roleUrl) { try { roleAudioBuffer = await fetchAndDecode(roleUrl); } catch(e){ console.warn('role clip load failed', e); } }

  if (startServerTime) scheduleBasePlaybackAndEndHandler();
  else {
    const unsub = onValue(sessionRef, snap => {
      const v = snap.val() || {};
      if (v.startServerTime && v.status === 'running') {
        startServerTime = v.startServerTime;
        scheduleBasePlaybackAndEndHandler();
        unsub();
      }
    });
  }
  renderNotesForRole();
  startCountdownUI(); // show countdown until base starts
}

function startCountdownUI() {
  if (!startServerTime) { countdownEl.style.display='none'; return; }
  countdownEl.style.display='block';
  const tick = () => {
    const nowClientMs = Date.now() + serverOffset;
    const remainMs = startServerTime - nowClientMs;
    if (remainMs <= 0) { countdownEl.style.display='none'; return; }
    const sec = Math.ceil(remainMs/1000);
    countdownEl.textContent = `開始まで残り：${sec}秒`;
    setTimeout(tick, 250);
  };
  tick();
}

function scheduleBasePlaybackAndEndHandler(){
  if (!audioContext || !baseAudioBuffer || !startServerTime) return;
  const nowClientMs = Date.now() + serverOffset;
  const elapsedMs = nowClientMs - startServerTime;
  const elapsedSec = Math.max(0, elapsedMs/1000);

  if (baseSourceNode) try{ baseSourceNode.disconnect(); }catch(e){}
  baseSourceNode = audioContext.createBufferSource();
  baseSourceNode.buffer = baseAudioBuffer;
  baseSourceNode.connect(audioContext.destination);

  if (elapsedSec <= 0) baseSourceNode.start(audioContext.currentTime + (-elapsedSec), 0);
  else {
    if (elapsedSec >= baseAudioBuffer.duration) { onBaseEnded(); return; }
    baseSourceNode.start(audioContext.currentTime, elapsedSec);
  }

  const remainingMs = (baseAudioBuffer.duration - elapsedSec) * 1000;
  if (baseEndTimer) clearTimeout(baseEndTimer);
  baseEndTimer = setTimeout(() => { onBaseEnded(); }, Math.max(0, remainingMs + 50));
}

function renderNotesForRole(){
  laneEl.querySelectorAll('.note').forEach(n => n.remove());
  const times = (assets && assets[userRole] && assets[userRole].guideTimes) || [];
  const travelMs = 3000;
  const baseServerStartMs = startServerTime || (Date.now() + serverOffset);
  times.forEach((gtime, idx) => {
    const targetMs = baseServerStartMs + Math.round(gtime*1000);
    const appearAt = targetMs - travelMs;
    const div = document.createElement('div');
    div.className = 'note';
    div.dataset.guide = String(gtime);
    div.dataset.appearAt = String(appearAt);
    div.dataset.targetAt = String(targetMs);
    div.style.background = (assets[userRole] && assets[userRole].color) || '#444';
    div.style.color = getContrastYIQ(assets[userRole] && assets[userRole].color || '#444');
    laneEl.appendChild(div);

    const animate = () => {
      const t = Date.now() + serverOffset;
      const pct = (t - appearAt) / travelMs;
      const laneHeight = laneEl.clientHeight;
      const startY = laneHeight - 16;
      const endY = 60;
      if (pct >= 1.5) { div.style.opacity='0'; setTimeout(()=>div.remove(),300); return; }
      if (pct <= 0) { div.style.bottom = `${startY}px`; requestAnimationFrame(animate); }
      else { const y = startY - (startY - endY) * Math.min(pct,1); div.style.bottom = `${y}px`; requestAnimationFrame(animate); }
    };
    requestAnimationFrame(animate);
  });
}

// record locally during play; after base ends send to DB
function recordLocalClick(){
  if (!startServerTime) { alert('まだ開始されていません'); return; }
  const clientNow = Date.now();
  const relativeMs = (clientNow + serverOffset) - startServerTime;
  const relativeSec = Math.max(0, relativeMs/1000);
  localClicks.push(relativeSec);
  const res = evaluateHitAndHandleNote(relativeSec);
  showTransientText(res === 'perfect' ? 'PERFECT' : 'MISS', res === 'perfect' ? '#8ef27a' : '#ff6b6b');
  broadcastAction(res === 'perfect' ? 'perfect' : 'miss');
}

function evaluateHitAndHandleNote(relativeSec){
  const notes = Array.from(laneEl.querySelectorAll('.note'));
  if (!notes.length) return evaluateHit(relativeSec);
  let bestNote = null; let bestDiff = Infinity;
  for (const n of notes) {
    const guide = parseFloat(n.dataset.guide) || 0;
    const d = Math.abs(guide - relativeSec);
    if (d < bestDiff) { bestDiff = d; bestNote = n; }
  }
  if (!bestNote) return evaluateHit(relativeSec);
  const isPerfect = bestDiff <= 0.5;
  const appearAt = Number(bestNote.dataset.appearAt);
  const targetMs = Number(bestNote.dataset.targetAt);
  const travelMs = targetMs - appearAt;
  const t = Date.now() + serverOffset;
  const pct = (t - appearAt) / (travelMs || 1);

  if (isPerfect) {
    playRoleClipNow();
    bestNote.remove();
    return 'perfect';
  } else {
    if (pct > 1) bestNote.remove();
    playMissClipNow();
    return 'miss';
  }
}

function evaluateHit(relativeSec){
  const times = (assets && assets[userRole] && assets[userRole].guideTimes) || [];
  let bestDiff = Infinity;
  for (const gt of times) {
    const d = Math.abs(gt - relativeSec);
    if (d < bestDiff) bestDiff = d;
  }
  return bestDiff <= 0.5 ? 'perfect' : 'miss';
}

async function playRoleClipNow(){
  try {
    if (!roleAudioBuffer && assets[userRole] && assets[userRole].clipUrl) roleAudioBuffer = await fetchAndDecode(assets[userRole].clipUrl);
    if (roleAudioBuffer && audioContext) { const src = audioContext.createBufferSource(); src.buffer = roleAudioBuffer; src.connect(audioContext.destination); src.start(); }
  } catch(e){ console.warn('playRoleClipNow failed', e); }
}
async function playMissClipNow(){
  try {
    if (!missAudioBuffer && assets['miss']) missAudioBuffer = await fetchAndDecode(assets['miss']);
    if (missAudioBuffer && audioContext) { const src = audioContext.createBufferSource(); src.buffer = missAudioBuffer; src.connect(audioContext.destination); src.start(); }
  } catch(e){ console.warn('playMissClipNow failed', e); }
}

async function broadcastAction(kind){
  try {
    await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), { kind, name: userName || uid, time: serverTimestamp() });
    setTimeout(async () => { try { await set(ref(db, `sessions/${sessionId}/realtimeActions/${uid}`), null); } catch(e){} }, 900);
  } catch(e){ console.warn(e); }
}
onValue(ref(db, `sessions/${sessionId}/realtimeActions`), snap => {
  const v = snap.val() || {}; topBallsEl.innerHTML = '';
  for (const [puid, data] of Object.entries(v)) {
    if (!data) continue;
    const b = document.createElement('div'); b.className = 'ball'; b.textContent = data.kind === 'perfect' ? 'P' : 'X'; topBallsEl.appendChild(b);
  }
});

function showTransientText(text, color){
  transientTextEl.style.color = color || '#fff';
  transientTextEl.textContent = text;
  transientTextEl.style.opacity = '1';
  setTimeout(()=> { transientTextEl.style.opacity = '0'; }, 700);
}

/* --------------------
   Base end and record flow
   -------------------- */
async function onBaseEnded(){
  console.log('ベース曲が終了');
  try {
    // write record object with times array and role & name
    const payload = { times: localClicks || [], role: userRole || null, name: userName || null };
    await set(ref(db, `sessions/${sessionId}/records/${uid}`), payload);
  } catch(e) { console.warn('send records failed', e); }

  // show waiting2
  waiting2El.style.display = 'block';
  waitingEl.style.display = 'none';
  gameEl.style.display = 'none';
  waiting2StatusEl.textContent = '全員の記録を集計中…';
  try { await update(sessionRef, { status: 'collecting' }); } catch(e){}
  // only owner should perform mixing; if I'm owner, run mix; else wait for finalData
  const sessionSnap = (await get(sessionRef)).val() || {};
  const ownerUid = sessionSnap.ownerUid;
  if (ownerUid && ownerUid === uid) {
    await ownerWaitAndMix();
  } else {
    // non-owners will just wait: UI will be updated when finalData arrives via listener above
  }
}

/* Owner mixing logic:
   - Use playersSnapshot recorded at start to determine expected uids
   - Add __auto_<role> entries for roles with no players
   - Wait for all records or timeout, then mix and write finalRecords + finalData (dataUrl) to DB
*/
async function ownerWaitAndMix() {
  try {
    // Lock mixing by writing mixLock (simple approach: owner writes mixLock=uid)
    try { await set(ref(db, `sessions/${sessionId}/mixLock`), { uid, ts: serverTimestamp() }); } catch(e){ console.warn('mixLock set failed', e); }

    const sessionSnap = (await get(sessionRef)).val() || {};
    const playersSnapshot = sessionSnap.playersSnapshot || sessionSnap.players || {};
    const expectedUids = Object.keys(playersSnapshot);
    const rolesOrder = sessionSnap.rolesOrder || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');

    for (const r of rolesOrder) {
      const assigned = Object.values(playersSnapshot || {}).some(p => p.role === r);
      if (!assigned) expectedUids.push(`__auto_${r}`);
    }

    const TIMEOUT_MS = 20000; // owner waits up to 20s for late records
    const startWait = Date.now();
    while (true) {
      const recSnap = (await get(ref(db, `sessions/${sessionId}/records`))).val() || {};
      const have = Object.keys(recSnap || {});
      const missing = expectedUids.filter(e => !have.includes(e));
      if (missing.length === 0) {
        waiting2StatusEl.textContent = '全員分到着：合成開始';
        await doMixAndPublish(recSnap, playersSnapshot);
        break;
      }
      if (Date.now() - startWait > TIMEOUT_MS) {
        waiting2StatusEl.textContent = 'タイムアウト: 現在ある記録で合成';
        const recs = recSnap;
        // synth missing __auto entries for mixing
        for (const r of rolesOrder) {
          const autoUid = `__auto_${r}`;
          if (!recs[autoUid]) {
            const guideTimes = assets[r] && assets[r].guideTimes || [];
            recs[autoUid] = { times: guideTimes.slice(), role: r, name: `AUTO_${r}` };
          }
        }
        await doMixAndPublish(recs, playersSnapshot);
        break;
      }
      await new Promise(r => setTimeout(r, 700));
    }
    // release mixLock
    try { await set(ref(db, `sessions/${sessionId}/mixLock`), null); } catch(e){}
  } catch(e) { console.error('ownerWaitAndMix failed', e); }
}

async function doMixAndPublish(allRecordsRaw, playersSnapshot) {
  // normalize records structure: ensure each entry has times array and role+name
  const records = {};
  for (const [puid, rec] of Object.entries(allRecordsRaw || {})) {
    if (!rec) continue;
    if (Array.isArray(rec)) { // legacy array form
      records[puid] = { times: rec.slice(), role: (playersSnapshot && playersSnapshot[puid] && playersSnapshot[puid].role) || rec.role || null, name: (playersSnapshot && playersSnapshot[puid] && playersSnapshot[puid].name) || rec.name || puid };
    } else {
      records[puid] = { times: rec.times ? (Array.isArray(rec.times) ? rec.times.slice() : []) : [], role: rec.role || (playersSnapshot && playersSnapshot[puid] && playersSnapshot[puid].role) || null, name: rec.name || (playersSnapshot && playersSnapshot[puid] && playersSnapshot[puid].name) || puid };
    }
  }
  // Add auto entries if missing (safety)
  const rolesOrder = (currentSessionSnapshot && currentSessionSnapshot.rolesOrder) || CONFIG.rolesOrder || Object.keys(assets || {}).filter(k => k !== '@' && k !== 'miss');
  for (const r of rolesOrder) {
    const has = Object.values(records || {}).some(rr => rr.role === r);
    if (!has) {
      const autoUid = `__auto_${r}`;
      if (!records[autoUid]) {
        records[autoUid] = { times: (assets[r] && assets[r].guideTimes) ? assets[r].guideTimes.slice() : [], role: r, name: `AUTO_${r}` };
      }
    }
  }

  // prepare mixing (OfflineAudioContext)
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  if (!baseAudioBuffer) {
    try { baseAudioBuffer = await fetchAndDecode(assets['@']); } catch(e){ console.error('base reload failed', e); return; }
  }

  let maxT = baseAudioBuffer.duration;
  for (const rec of Object.values(records)) for (const t of rec.times || []) if (t && t > maxT) maxT = t;
  const sampleRate = 44100;
  const off = new OfflineAudioContext(2, Math.ceil((maxT + 2) * sampleRate), sampleRate);

  // base
  const baseSrc = off.createBufferSource(); baseSrc.buffer = baseAudioBuffer; baseSrc.connect(off.destination); baseSrc.start(0);

  // schedule each player's times with their clip
  for (const [puid, rec] of Object.entries(records)) {
    const role = rec.role || (playersSnapshot && playersSnapshot[puid] && playersSnapshot[puid].role) || puid.replace('__auto_','');
    const clipUrl = assets[role] && assets[role].clipUrl;
    if (!clipUrl) continue;
    try {
      const clipBuf = await fetchAndDecode(clipUrl);
      for (const t of rec.times || []) {
        const src = off.createBufferSource(); src.buffer = clipBuf; src.connect(off.destination); src.start(t);
      }
    } catch(e) { console.warn('clip load failed for', role, e); continue; }
  }

  waiting2StatusEl.textContent = '合成中…';
  const rendered = await off.startRendering();

  // encode to mp3 if possible (lame), else wav
  await loadLameJs().catch(()=>{});
  let blob;
  if (typeof lamejs !== 'undefined') blob = audioBufferToMp3(rendered);
  else blob = audioBufferToWav(rendered);

  // convert to dataURL
  const dataUrl = await blobToDataURL(blob);

  // write finalRecords (numeric) and finalData (dataUrl) in DB so everyone gets the same final
  try {
    await set(ref(db, `sessions/${sessionId}/finalRecords`), records);
    await set(ref(db, `sessions/${sessionId}/finalData`), { dataUrl, generatedBy: uid, generatedAt: serverTimestamp() });
  } catch(e) { console.warn('publish final failed', e); }

  waiting2StatusEl.textContent = '合成完了';
}

/* ----------------------
   MP3 encoding helpers
   ---------------------- */
let lameLoaded = false;
async function loadLameJs() {
  if (lameLoaded) return;
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js';
    s.onload = () => { lameLoaded = true; resolve(); };
    s.onerror = (e) => { console.warn('lamejs load failed', e); reject(e); };
    document.head.appendChild(s);
  });
}
function audioBufferToMp3(audioBuffer) {
  if (typeof lamejs === 'undefined') return audioBufferToWav(audioBuffer);
  const left = audioBuffer.getChannelData(0);
  const right = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : left;
  const samples = interleaveFloat32(left, right);
  const mp3encoder = new lamejs.Mp3Encoder(2, audioBuffer.sampleRate, 128);
  const mp3Data = []; const sampleBlockSize = 1152;
  let idx = 0;
  while (idx < samples.length) {
    const leftChunk = [], rightChunk = [];
    for (let i=0;i<sampleBlockSize && idx < samples.length;i+=2) {
      leftChunk.push(samples[idx]); rightChunk.push(samples[idx+1]); idx+=2;
    }
    const left16 = floatTo16BitPCMArray(leftChunk);
    const right16 = floatTo16BitPCMArray(rightChunk);
    const mp3buf = mp3encoder.encodeBuffer(left16, right16);
    if (mp3buf.length > 0) mp3Data.push(mp3buf);
  }
  const mp3buf = mp3encoder.flush(); if (mp3buf.length > 0) mp3Data.push(mp3buf);
  return new Blob(mp3Data, { type: 'audio/mp3' });
}
function interleaveFloat32(left, right) {
  const length = left.length + right.length;
  const result = new Float32Array(length);
  let index = 0, inputIndex = 0;
  while (inputIndex < left.length) { result[index++] = left[inputIndex]; result[index++] = right[inputIndex]; inputIndex++; }
  return result;
}
function floatTo16BitPCMArray(float32Array) {
  const out = new Int16Array(float32Array.length);
  for (let i=0;i<float32Array.length;i++){ let s = Math.max(-1, Math.min(1, float32Array[i])); out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF; }
  return out;
}

/* ----------
   Utilities
   ---------- */
async function fetchAndDecode(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error('fetch failed: ' + res.status);
  const ab = await res.arrayBuffer();
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  return await audioContext.decodeAudioData(ab);
}
function blobToDataURL(blob) {
  return new Promise((resolve) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.readAsDataURL(blob);
  });
}
function audioBufferToWav(buffer, opt) {
  opt = opt || {};
  var numChannels = buffer.numberOfChannels;
  var sampleRate = buffer.sampleRate;
  var format = opt.float32 ? 3 : 1;
  var bitDepth = format === 3 ? 32 : 16;
  var result;
  if (numChannels === 2) result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
  else result = buffer.getChannelData(0);
  return encodeWAV(result, format, sampleRate, numChannels, bitDepth);
}
function interleave(inputL, inputR){
  var length = inputL.length + inputR.length;
  var result = new Float32Array(length);
  var index = 0, inputIndex = 0;
  while (index < length){ result[index++] = inputL[inputIndex]; result[index++] = inputR[inputIndex]; inputIndex++; }
  return result;
}
function encodeWAV(samples, format, sampleRate, numChannels, bitDepth){
  var bytesPerSample = bitDepth / 8; var blockAlign = numChannels * bytesPerSample;
  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
  var view = new DataView(buffer);
  writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + samples.length * bytesPerSample, true); writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, format === 3 ? 3 : 1, true);
  view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true); view.setUint16(34, bitDepth, true); writeString(view, 36, 'data');
  view.setUint32(40, samples.length * bytesPerSample, true);
  if (format === 1) floatTo16BitPCM(view, 44, samples); else writeFloat32(view, 44, samples);
  return new Blob([buffer], { type: 'audio/wav' });
}
function floatTo16BitPCM(output, offset, input){
  for (var i = 0; i < input.length; i++, offset += 2){ var s = Math.max(-1, Math.min(1, input[i])); output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true); }
}
function writeFloat32(output, offset, input){
  for (var i = 0; i < input.length; i++, offset += 4){ output.setFloat32(offset, input[i], true); }
}
function writeString(view, offset, string){ for (var i = 0; i < string.length; i++){ view.setUint8(offset + i, string.charCodeAt(i)); } }

function onDownloadMP3() {
  const url = downloadBtn.dataset.url || waiting2Download.dataset.url;
  if (!url) return alert('生成された音声がありません');
  const a = document.createElement('a'); a.href = url; a.download = 'gassaku.mp3'; a.click();
}
function onDownloadWaiting2MP3() { onDownloadMP3(); }

async function estimateServerOffset() {
  const rand = Math.random().toString(36).slice(2, 8);
  const pings = [];
  for (let i=0;i<6;i++){
    const t0 = Date.now();
    const tmpRef = ref(db, `__serverTimeTest/${uid}_${rand}_${i}`);
    try {
      await set(tmpRef, {ts: serverTimestamp()});
      const snap = await get(tmpRef);
      const serverTs = snap.val() && snap.val().ts;
      const t1 = Date.now();
      if (serverTs) { const rtt = t1 - t0; const offset = serverTs - (t0 + rtt/2); pings.push(offset); }
    } catch(e){ console.warn('ping failed', e); }
    await new Promise(r=>setTimeout(r,50));
  }
  if (pings.length) { pings.sort((a,b)=>a-b); serverOffset = pings[Math.floor(pings.length/2)]; console.log('serverOffset', serverOffset); } else serverOffset = 0;
}

function getContrastYIQ(hexcolor){
  try {
    if (!hexcolor || !hexcolor.startsWith('#')) return '#fff';
    const r = parseInt(hexcolor.substr(1,2),16), g = parseInt(hexcolor.substr(3,2),16), b = parseInt(hexcolor.substr(5,2),16);
    const yiq = ((r*299)+(g*587)+(b*114))/1000;
    return (yiq >= 128) ? '#000' : '#fff';
  } catch(e){ return '#fff'; }
}
function adjustLaneHeight(){
  const h = Math.max(360, window.innerHeight * 0.62);
  laneEl.style.height = `${h}px`;
}

  </script>
</body>
</html>
